<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>D&D Helper - Dashboard</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .dashboard-container {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .tab-container {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
        }
        
        .tab-button {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px 8px 0 0;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .tab-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .tab-button.active {
            background: rgba(255, 255, 255, 0.25);
            border-bottom: 3px solid #f39c12;
        }
        
        .tab-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0 10px 10px 10px;
            padding: 20px;
            overflow: hidden;
            display: none;
        }
        
        .tab-content.active {
            display: flex;
            flex-direction: column;
        }
        
        /* Media Grid Styles */
        .media-grid-container {
            flex: 1;
            overflow-y: auto;
        }
        
        .directory-nav {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }
        
        .breadcrumb {
            font-size: 14px;
            opacity: 0.8;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .breadcrumb-item {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 3px;
            transition: all 0.2s ease;
        }
        
        .breadcrumb-item:hover {
            background: rgba(255, 255, 255, 0.1);
            opacity: 1;
        }
        
        .breadcrumb-separator {
            opacity: 0.5;
            margin: 0 2px;
        }
        
        .media-section {
            margin-bottom: 30px;
        }
        
        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 15px 0;
            padding: 8px 0;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            color: #f39c12;
        }
        
        .media-grid-section {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
            padding: 5px 0;
        }
        
        .media-grid {
            padding: 10px 0;
        }
        
        .media-item {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 2px solid transparent;
        }
        
        .media-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .media-item.portrait:hover {
            border-color: #e74c3c;
        }
        
        .media-item.background:hover,
        .media-item.background-video:hover {
            border-color: #27ae60;
        }
        
        .media-item.event:hover {
            border-color: #f39c12;
        }
        
        .media-item.folder:hover {
            border-color: #3498db;
        }
        
        .media-item.image:hover {
            border-color: #9b59b6;
        }
        
        /* Type indicator badges */
        .media-item .type-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 8px;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
        
        .media-item:hover .type-badge {
            opacity: 1;
        }
        
        .media-item.portrait .type-badge {
            background: #e74c3c;
        }
        
        .media-item.background .type-badge,
        .media-item.background-video .type-badge {
            background: #27ae60;
        }
        
        .media-item.event .type-badge {
            background: #f39c12;
        }
        
        .media-item.folder:hover {
            border-color: #3498db;
        }
        
        .media-preview {
            width: 70px;
            height: 70px;
            object-fit: cover;
            border-radius: 5px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .media-icon {
            font-size: 36px;
            margin-bottom: 8px;
            opacity: 0.7;
        }
        
        .media-name {
            font-size: 11px;
            font-weight: 500;
            opacity: 0.9;
            word-break: break-word;
            line-height: 1.2;
            max-height: 2.4em;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        
        .media-type-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            padding: 2px 5px;
            border-radius: 8px;
            font-size: 9px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .media-item.image .media-type-badge { background: #e74c3c; }
        .media-item.video .media-type-badge { background: #f39c12; }
        .media-item.folder .media-type-badge { background: #3498db; }
        .media-item.portrait .media-type-badge { background: #e74c3c; }
        .media-item.background .media-type-badge { background: #27ae60; }
        .media-item.event .media-type-badge { background: #f39c12; }
        
        /* Audio List Styles */
        .audio-list-container {
            flex: 1;
            overflow-y: auto;
        }
        
        .audio-section {
            margin-bottom: 25px;
        }
        
        .audio-section h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #f39c12;
            border-bottom: 2px solid rgba(243, 156, 18, 0.3);
            padding-bottom: 5px;
        }
        
        .audio-file-item {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
        }
        
        .audio-file-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(2px);
        }
        
        .audio-file-item.sound { border-left: 3px solid #9b59b6; }
        .audio-file-item.loop { border-left: 3px solid #e67e22; }
        .audio-file-item.music { border-left: 3px solid #3498db; }
        .audio-file-item.folder-item { border-left: 3px solid #27ae60; }
        .audio-file-item.back-item { border-left: 3px solid #95a5a6; }
        
        .audio-icon {
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .audio-name {
            flex: 1;
            font-size: 13px;
        }
        
        .audio-badge {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
            opacity: 0.7;
        }
        
        .audio-file-item.sound .audio-badge { background: #9b59b6; }
        .audio-file-item.loop .audio-badge { background: #e67e22; }
        .audio-file-item.music .audio-badge { background: #3498db; }
        
        /* Audio breadcrumbs */
        .audio-breadcrumbs {
            margin-bottom: 10px;
            padding: 8px 12px;
            background: rgba(243, 156, 18, 0.1);
            border-radius: 5px;
            border-left: 3px solid #f39c12;
        }
        
        /* Unified audio list */
        .unified-audio-list {
            padding: 0;
        }
        
        .audio-icon {
            font-size: 16px;
            opacity: 0.7;
        }
        
        .audio-name {
            flex: 1;
            font-size: 14px;
        }
        
        /* Live Panel Styles */
        .live-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
        }
        
        .live-panel h2 {
            margin-top: 0;
            color: #f39c12;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .display-section {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 5px;
            border-left: 4px solid transparent;
        }
        
        .display-section.portraits { border-left-color: #e74c3c; }
        .display-section.background { border-left-color: #27ae60; }
        .display-section.event { border-left-color: #f39c12; }
        .display-section.audio { border-left-color: #9b59b6; }
        
        .display-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }
        
        .volume-slider {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        
        .volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: #f39c12;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .volume-label {
            font-size: 12px;
            opacity: 0.8;
            min-width: 30px;
        }
        
        .clear-btn {
            background: rgba(231, 76, 60, 0.7);
            border: none;
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .clear-btn:hover {
            background: rgba(231, 76, 60, 0.9);
        }
        
        .clear-all-btn {
            background: rgba(231, 76, 60, 0.7);
            border: none;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
        }
        
        .clear-all-btn:hover {
            background: rgba(231, 76, 60, 0.9);
        }
        
        .empty-state {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .file-explorer {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        
        .folder-item, .file-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin: 2px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .folder-item:hover, .file-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .folder-item.open {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .folder-icon, .file-icon {
            margin-right: 8px;
            font-size: 16px;
        }
        
        .folder-children {
            margin-left: 20px;
            border-left: 1px solid rgba(255, 255, 255, 0.2);
            padding-left: 10px;
        }
        
        .file-item.image.portrait { color: #e74c3c; }
        .file-item.image.background { color: #27ae60; }
        .file-item.video.event { color: #f39c12; }
        .file-item.video.background { color: #27ae60; }
        .file-item.audio.sound { color: #9b59b6; }
        .file-item.audio.loop { color: #e67e22; }
        .file-item.audio.music { color: #3498db; }
        
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
        }
        
        .error {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* Party Editor Styles */
        .party-editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .party-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #f39c12;
        }
        
        .party-header h3 {
            margin: 0;
            color: #f39c12;
            font-size: 20px;
        }
        
        .party-actions {
            display: flex;
            gap: 10px;
        }
        
        .add-player-btn, .save-party-btn, .load-party-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .add-player-btn {
            background: rgba(46, 204, 113, 0.7);
            color: white;
        }
        
        .add-player-btn:hover {
            background: rgba(46, 204, 113, 0.9);
        }
        
        .save-party-btn {
            background: rgba(52, 152, 219, 0.7);
            color: white;
        }
        
        .save-party-btn:hover {
            background: rgba(52, 152, 219, 0.9);
        }
        
        .load-party-btn {
            background: rgba(155, 89, 182, 0.7);
            color: white;
        }
        
        .load-party-btn:hover {
            background: rgba(155, 89, 182, 0.9);
        }
        
        .party-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }
        
        .player-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
            display: grid;
            grid-template-columns: 100px 1fr auto;
            gap: 20px;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .player-card:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(2px);
        }
        
        .player-portrait {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background-size: cover;
            background-position: center;
            position: relative;
        }
        
        .player-portrait:hover {
            border-color: #3498db;
            background-color: rgba(52, 152, 219, 0.1);
        }
        
        .player-portrait.has-image {
            border-color: #27ae60;
        }
        
        .player-portrait .portrait-icon {
            font-size: 32px;
            opacity: 0.6;
        }
        
        .player-portrait.has-image .portrait-icon {
            display: none;
        }
        
        .player-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .player-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .player-field label {
            font-size: 12px;
            font-weight: 600;
            color: #f39c12;
            text-transform: uppercase;
        }
        
        .player-field input, .player-field select {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 14px;
        }
        
        .player-field input:focus, .player-field select:focus {
            outline: none;
            border-color: #3498db;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .player-field input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .player-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .stat-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stat-label {
            font-size: 11px;
            font-weight: 600;
            color: #ecf0f1;
            min-width: 60px;
            text-transform: uppercase;
        }
        
        .stat-input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 13px;
            text-align: center;
        }
        
        .player-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }
        
        .remove-player-btn {
            background: rgba(231, 76, 60, 0.7);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .remove-player-btn:hover {
            background: rgba(231, 76, 60, 0.9);
        }
        
        /* Portrait Selection Modal */
        .portrait-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .portrait-modal.active {
            display: flex;
        }
        
        /* Generic Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            border-radius: 10px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
        }
        
        .modal-header h3 {
            margin: 0;
            color: #fff;
            font-size: 18px;
        }
        
        .close {
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
        }
        
        .close:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .portrait-modal-content {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            border-radius: 10px;
            padding: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        
        .portrait-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .portrait-modal-title {
            color: #f39c12;
            margin: 0;
            font-size: 18px;
        }
        
        .portrait-search-container {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .portrait-search-input {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            box-sizing: border-box;
            margin-bottom: 8px;
        }
        
        .portrait-search-info {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
        }
        
        .portrait-search-input:focus {
            outline: none;
            border-color: #3498db;
            background: rgba(255, 255, 255, 0.15);
        }
        
        .portrait-search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .close-modal-btn {
            background: rgba(231, 76, 60, 0.7);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .close-modal-btn:hover {
            background: rgba(231, 76, 60, 0.9);
        }
        
        .portrait-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
        }
        
        .portrait-option {
            width: 100px;
            height: 100px;
            border-radius: 8px;
            background-size: cover;
            background-position: center;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            flex-direction: column;
        }
        
        .portrait-option:hover {
            border-color: #3498db;
            transform: scale(1.05);
        }
        
        .portrait-option.no-image {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.6);
            font-size: 24px;
        }
        
        .portrait-option.hidden {
            display: none;
        }
        
        .portrait-name {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .portrait-option:hover .portrait-name {
            opacity: 1;
        }
        
        /* Encounter Builder Styles */
        .encounter-editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .encounter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #e74c3c;
        }
        
        .encounter-header h3 {
            margin: 0;
            color: #e74c3c;
            font-size: 20px;
        }
        
        .encounter-actions {
            display: flex;
            gap: 10px;
        }
        
        .new-encounter-btn, .save-encounter-btn, .load-encounter-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .new-encounter-btn {
            background: rgba(52, 152, 219, 0.7);
            color: white;
        }
        
        .new-encounter-btn:hover {
            background: rgba(52, 152, 219, 0.9);
        }
        
        .save-encounter-btn {
            background: rgba(46, 204, 113, 0.7);
            color: white;
        }
        
        .save-encounter-btn:hover {
            background: rgba(46, 204, 113, 0.9);
        }
        
        .load-encounter-btn {
            background: rgba(155, 89, 182, 0.7);
            color: white;
        }
        
        .load-encounter-btn:hover {
            background: rgba(155, 89, 182, 0.9);
        }
        
        .current-encounter-info {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .encounter-name-input {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            font-weight: 600;
        }
        
        .encounter-name-input:focus {
            outline: none;
            border-color: #e74c3c;
            background: rgba(255, 255, 255, 0.15);
        }
        
        .encounter-name-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .add-enemy-btn {
            padding: 10px 20px;
            background: rgba(231, 76, 60, 0.7);
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .add-enemy-btn:hover {
            background: rgba(231, 76, 60, 0.9);
        }
        
        .encounter-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }
        
        .enemy-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #e74c3c;
            display: grid;
            grid-template-columns: 100px 1fr auto;
            gap: 20px;
            align-items: start;
            transition: all 0.3s ease;
        }
        
        .enemy-card:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(2px);
        }
        
        .enemy-portrait {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background-size: cover;
            background-position: center;
            position: relative;
        }
        
        .enemy-portrait:hover {
            border-color: #e74c3c;
            background-color: rgba(231, 76, 60, 0.1);
        }
        
        .enemy-portrait.has-image {
            border-color: #27ae60;
        }
        
        .enemy-portrait .portrait-icon {
            font-size: 32px;
            opacity: 0.6;
        }
        
        .enemy-portrait.has-image .portrait-icon {
            display: none;
        }
        
        .enemy-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .enemy-basic-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .enemy-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .enemy-description {
            margin-top: 10px;
        }
        
        .enemy-description label {
            font-size: 11px;
            font-weight: 600;
            color: #e74c3c;
            text-transform: uppercase;
            display: block;
            margin-bottom: 5px;
        }
        
        .enemy-description textarea {
            width: 100%;
            min-height: 80px;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 12px;
            resize: vertical;
            font-family: inherit;
        }
        
        .enemy-description textarea:focus {
            outline: none;
            border-color: #e74c3c;
        }
        
        .enemy-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .enemy-field label {
            font-size: 11px;
            font-weight: 600;
            color: #e74c3c;
            text-transform: uppercase;
        }
        
        .enemy-field input {
            padding: 6px 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 13px;
        }
        
        .enemy-field input:focus {
            outline: none;
            border-color: #e74c3c;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .enemy-field input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .stat-field {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .stat-field label {
            font-size: 10px;
            font-weight: 600;
            color: #ecf0f1;
            text-transform: uppercase;
        }
        
        .stat-field input {
            padding: 4px 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 12px;
            text-align: center;
            width: 60px;
        }
        
        .enemy-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }
        
        .remove-enemy-btn {
            background: rgba(231, 76, 60, 0.7);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .remove-enemy-btn:hover {
            background: rgba(231, 76, 60, 0.9);
        }
        
        .enemy-name-input {
            font-size: 16px !important;
            font-weight: 600 !important;
            padding: 8px 12px !important;
        }
        
        /* Encounter Selection Modal */
        .encounter-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .encounter-modal.active {
            display: flex;
        }
        
        .encounter-modal-content {
            background: linear-gradient(135deg, #2c3e50 0%, #e74c3c 100%);
            border-radius: 10px;
            padding: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        
        .encounter-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .encounter-modal-title {
            color: #f39c12;
            margin: 0;
            font-size: 18px;
        }
        
        .encounter-list-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .encounter-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid #e74c3c;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .encounter-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(2px);
        }
        
        .encounter-item-info {
            flex: 1;
        }
        
        .encounter-item-name {
            font-size: 16px;
            font-weight: 600;
            color: white;
            margin-bottom: 5px;
        }
        
        .encounter-item-details {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            display: flex;
            gap: 15px;
        }
        
        .encounter-item-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }
        
        .encounter-item-date {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .encounter-enemy-count {
            background: rgba(231, 76, 60, 0.8);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .no-encounters {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }
        
        /* Initiative Tracker Styles */
        .initiative-tracker-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .initiative-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #f39c12;
        }
        
        .initiative-header h3 {
            margin: 0;
            color: #f39c12;
            font-size: 20px;
        }
        
        .initiative-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .round-counter {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(243, 156, 18, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid rgba(243, 156, 18, 0.4);
        }
        
        .round-label {
            font-size: 14px;
            color: #f39c12;
            font-weight: 600;
        }
        
        .round-number {
            font-size: 18px;
            font-weight: 700;
            color: white;
            min-width: 30px;
            text-align: center;
        }
        
        .turn-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .prev-turn {
            background: rgba(155, 89, 182, 0.7);
            color: white;
        }
        
        .prev-turn:hover {
            background: rgba(155, 89, 182, 0.9);
        }
        
        .next-turn {
            background: rgba(46, 204, 113, 0.7);
            color: white;
        }
        
        .next-turn:hover {
            background: rgba(46, 204, 113, 0.9);
        }
        
        .initiative-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            flex-wrap: wrap;
        }
        
        .initiative-action-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .add-party {
            background: rgba(52, 152, 219, 0.7);
            color: white;
        }
        
        .add-party:hover {
            background: rgba(52, 152, 219, 0.9);
        }
        
        .add-encounter {
            background: rgba(231, 76, 60, 0.7);
            color: white;
        }
        
        .add-encounter:hover {
            background: rgba(231, 76, 60, 0.9);
        }
        
        .add-note {
            background: rgba(243, 156, 18, 0.7);
            color: white;
        }
        
        .add-note:hover {
            background: rgba(243, 156, 18, 0.9);
        }
        
        .clear-initiative {
            background: rgba(127, 140, 141, 0.7);
            color: white;
        }
        
        .clear-initiative:hover {
            background: rgba(127, 140, 141, 0.9);
        }
        
        .initiative-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }
        
        .initiative-item {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .initiative-item.current-turn {
            background: rgba(46, 204, 113, 0.2);
            border: 2px solid rgba(46, 204, 113, 0.6);
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.3);
            transform: scale(1.02);
        }
        
        .initiative-item.player {
            border-left: 4px solid #3498db;
        }
        
        .initiative-item.enemy {
            border-left: 4px solid #e74c3c;
        }
        
        .initiative-item.note {
            border-left: 4px solid #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }
        
        .initiative-portrait {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .initiative-portrait.has-image {
            border-color: #27ae60;
        }
        
        .initiative-portrait.has-image .initiative-icon {
            display: none;
        }
        
        .initiative-item.enemy .initiative-portrait {
            cursor: pointer;
        }
        
        .initiative-item.enemy .initiative-portrait:hover {
            border-color: #3498db;
            transform: scale(1.05);
            transition: all 0.2s;
        }
        
        .initiative-icon {
            font-size: 20px;
            opacity: 0.7;
        }
        
        .initiative-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .initiative-name {
            font-size: 16px;
            font-weight: 600;
            color: white;
        }
        
        .initiative-type {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .initiative-order {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .initiative-input {
            width: 60px;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
        }
        
        .hp-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .hp-display {
            font-weight: bold;
            min-width: 50px;
            text-align: center;
            font-size: 14px;
        }
        
        .hp-display.low-hp {
            color: #e74c3c;
        }
        
        .hp-display.half-hp {
            color: #f39c12;
        }
        
        .hp-button {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .hp-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .hp-button.damage {
            border-color: #e74c3c;
        }
        
        .hp-button.heal {
            border-color: #27ae60;
        }
        
        .hp-display {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .hp-display:hover {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 2px 4px;
            margin: -2px -4px;
        }
        
        .hp-modal {
            max-width: 400px;
        }
        
        .hp-modal .modal-header h3 {
            margin: 0;
            color: #fff;
        }
        
        .hp-modal-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .damage-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .damage-btn:hover {
            background: #c0392b;
        }
        
        .heal-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .heal-btn:hover {
            background: #229954;
        }
        
        .info-btn {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
            color: #3498db;
            width: 25px;
            height: 25px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 5px;
        }
        
        .info-btn:hover {
            background: rgba(52, 152, 219, 0.3);
        }
        
        .enemy-info-modal {
            max-width: 90%;
            width: 800px;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .enemy-info-content {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
            min-height: 300px;
        }
        
        .enemy-info-left {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .enemy-info-right {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .enemy-portrait-section {
            text-align: center;
        }
        
        .enemy-portrait-large {
            width: 120px;
            height: 120px;
            border-radius: 60px;
            background-size: cover;
            background-position: center;
            background-color: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            margin: 0 auto 10px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
        }
        
        .enemy-name-large {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            margin: 0;
        }
        
        .enemy-type-info {
            color: #bbb;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .enemy-vital-stats {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
        }
        
        .vital-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .vital-stat-row:last-child {
            border-bottom: none;
        }
        
        .vital-stat-label {
            font-weight: bold;
            color: #e74c3c;
            font-size: 12px;
            text-transform: uppercase;
        }
        
        .vital-stat-value {
            font-size: 16px;
            color: #fff;
        }
        
        .enemy-stat-block {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .enemy-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 10px 0;
        }
        
        .stat-item {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 12px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .stat-item .stat-name {
            font-size: 11px;
            color: #e74c3c;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        
        .stat-item .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: white;
            margin-bottom: 3px;
        }
        
        .stat-item .stat-modifier {
            font-size: 14px;
            color: #bbb;
        }
        
        .enemy-description-section {
            background: rgba(0, 0, 0, 0.2);
            border-left: 3px solid #e74c3c;
            border-radius: 0 8px 8px 0;
            padding: 20px;
            flex-grow: 1;
            min-height: 200px;
        }
        
        .enemy-description-section h4 {
            margin: 0 0 15px 0;
            color: #e74c3c;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .enemy-description-text {
            white-space: pre-wrap;
            line-height: 1.6;
            color: #ddd;
            font-size: 14px;
        }
        
        .empty-description {
            color: #888;
            font-style: italic;
            text-align: center;
            padding: 40px 20px;
        }
        
        .initiative-input:focus {
            outline: none;
            border-color: #f39c12;
            background: rgba(255, 255, 255, 0.2);
        }
        
        .initiative-actions-cell {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .remove-initiative-btn {
            background: rgba(231, 76, 60, 0.7);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }
        
        .remove-initiative-btn:hover {
            background: rgba(231, 76, 60, 0.9);
        }
        
        .current-turn-indicator {
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            background: #2ecc71;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.5);
        }
        
        /* Note Modal Styles */
        .note-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .note-modal.active {
            display: flex;
        }
        
        .note-modal-content {
            background: linear-gradient(135deg, #2c3e50 0%, #f39c12 100%);
            border-radius: 10px;
            padding: 20px;
            max-width: 400px;
            width: 90%;
        }
        
        .note-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .note-modal-title {
            color: #f39c12;
            margin: 0;
            font-size: 18px;
        }
        
        .note-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .note-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .note-field label {
            font-size: 14px;
            font-weight: 600;
            color: white;
        }
        
        .note-field input, .note-field textarea {
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
        }
        
        .note-field textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .note-field input:focus, .note-field textarea:focus {
            outline: none;
            border-color: #f39c12;
            background: rgba(255, 255, 255, 0.2);
        }
        
        .note-field input::placeholder, .note-field textarea::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .note-modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        .note-modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .note-cancel-btn {
            background: rgba(127, 140, 141, 0.7);
            color: white;
        }
        
        .note-cancel-btn:hover {
            background: rgba(127, 140, 141, 0.9);
        }
        
        .note-add-btn {
            background: rgba(243, 156, 18, 0.7);
            color: white;
        }
        
        .note-add-btn:hover {
            background: rgba(243, 156, 18, 0.9);
        }

        /* Battlemap Styles */
        .battlemap-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 15px;
        }

        .battlemap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .battlemap-header h3 {
            margin: 0;
            color: #e67e22;
            font-size: 20px;
        }

        .battlemap-actions {
            display: flex;
            gap: 10px;
        }

        .battlemap-action-btn {
            background: rgba(230, 126, 34, 0.7);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .battlemap-action-btn:hover {
            background: rgba(230, 126, 34, 0.9);
            transform: translateY(-2px);
        }

        .clear-battlemap {
            background: rgba(231, 76, 60, 0.7);
        }

        .clear-battlemap:hover {
            background: rgba(231, 76, 60, 0.9);
        }

        .battlemap-config {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
        }

        .grid-config {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .grid-dimension-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .grid-size-input {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .aspect-ratio-info {
            padding: 5px 10px;
            background: rgba(52, 152, 219, 0.2);
            border-radius: 4px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .aspect-ratio-info small {
            color: #3498db;
        }

        .zoom-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-left: 15px;
        }

        .zoom-controls button {
            font-size: 12px;
            padding: 6px 12px;
        }

        .focus-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-left: 15px;
        }

        .focus-controls button {
            font-size: 12px;
            padding: 6px 12px;
        }

        /* Character Focus Modal */
        .character-focus-content {
            max-height: 400px;
            overflow-y: auto;
        }

        .character-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .character-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid #3498db;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .character-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(2px);
        }

        .character-portrait-small {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: white;
        }

        .character-info {
            flex: 1;
        }

        .character-name {
            font-size: 16px;
            font-weight: 600;
            color: white;
            margin-bottom: 4px;
        }

        .character-position {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        /* Battlemap Context Menu */
        .battlemap-context-menu {
            position: fixed;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 8px 0;
            z-index: 1000;
            min-width: 160px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: none;
        }

        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .context-menu-item:hover {
            background: rgba(52, 152, 219, 0.3);
        }

        .context-menu-item:active {
            background: rgba(52, 152, 219, 0.5);
        }

        .context-menu-icon {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }

        .context-menu-separator {
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
            margin: 4px 0;
        }

        .grid-config label {
            font-weight: bold;
            color: #e67e22;
            font-size: 14px;
        }

        .grid-config input {
            width: 60px;
            padding: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            text-align: center;
        }

        .battlemap-grid-container {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 20px;
            overflow: auto;
            position: relative;
        }

        .battlemap-grid {
            display: grid;
            gap: 1px;
            background: #2c3e50;
            border: 2px solid #34495e;
            border-radius: 4px;
            margin: 0 auto;
            position: relative;
            background-size: cover;
            background-position: top left;
            background-repeat: no-repeat;
            background-attachment: local;
            width: fit-content;
        }

        .battlemap-cell {
            aspect-ratio: 1;
            min-width: 30px;
            min-height: 30px;
            background: rgba(52, 73, 94, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .battlemap-cell:hover {
            background: rgba(52, 152, 219, 0.3);
            border-color: #3498db;
        }

        .battlemap-cell.occupied {
            background: rgba(46, 204, 113, 0.5);
            border-color: #27ae60;
        }

        .battlemap-cell.occupied:hover {
            background: rgba(46, 204, 113, 0.7);
        }

        .battlemap-token {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            border: 2px solid #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            position: relative;
        }

        .battlemap-token.no-image {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            font-weight: bold;
        }

        .battlemap-token.selected-for-move {
            border: 3px solid #f39c12;
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.8);
            animation: pulse-move 1s ease-in-out infinite alternate;
        }

        .battlemap-token.hidden-token {
            opacity: 0.3;
            filter: grayscale(50%);
        }

        .battlemap-token.hidden-token .token-name {
            opacity: 0.7;
            font-style: italic;
        }

        @keyframes pulse-move {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        .battlemap-cell.move-target {
            background: rgba(243, 156, 18, 0.4);
            cursor: crosshair;
        }

        .battlemap-cell.move-target:hover {
            background: rgba(243, 156, 18, 0.6);
        }

        .move-mode-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(243, 156, 18, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }

        .token-name {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            white-space: nowrap;
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .battlemap-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.7;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="main-content">
            <div class="header">
                <h1>🎲 D&D Helper Dashboard</h1>
                <button id="refreshBtn">🔄 Refresh</button>
            </div>
            
            <div class="tab-container">
                <button class="tab-button active" onclick="switchTab('media')">🖼️ Media</button>
                <button class="tab-button" onclick="switchTab('audio')">🎵 Audio</button>
                <button class="tab-button" onclick="switchTab('party')">👥 Party</button>
                <button class="tab-button" onclick="switchTab('encounters')">⚔️ Encounters</button>
                <button class="tab-button" onclick="switchTab('initiative')">🎲 Initiative</button>
                <button class="tab-button" onclick="switchTab('battlemap')">🗺️ Battlemap</button>
            </div>
            
            <div id="mediaTab" class="tab-content active">
                <div class="media-grid-container">
                    <div class="directory-nav">
                        <span class="breadcrumb" id="currentPath">Loading...</span>
                        <button id="refreshBtn2" style="margin-left: auto; padding: 5px 10px; background: rgba(255,255,255,0.1); border: none; color: white; border-radius: 3px; cursor: pointer;">🔄</button>
                    </div>
                    <div class="media-grid" id="mediaGrid">
                        <div class="loading">Loading media files...</div>
                    </div>
                </div>
            </div>
            
            <div id="audioTab" class="tab-content">
                <div class="audio-list-container">
                    <div id="audioList" class="unified-audio-list">
                        <div class="empty-state">Loading audio files...</div>
                    </div>
                </div>
            </div>
            
            <div id="partyTab" class="tab-content">
                <div class="party-editor-container">
                    <div class="party-header">
                        <h3>🎲 Party Configuration</h3>
                        <div class="party-actions">
                            <button id="addPlayerBtn" class="add-player-btn">➕ Add Player</button>
                            <button id="savePartyBtn" class="save-party-btn">💾 Save Party</button>
                            <button id="loadPartyBtn" class="load-party-btn">📁 Load Party</button>
                        </div>
                    </div>
                    <div id="partyList" class="party-list">
                        <div class="empty-state">No players in party. Click "Add Player" to get started!</div>
                    </div>
                </div>
            </div>
            
            <div id="encountersTab" class="tab-content">
                <div class="encounter-editor-container">
                    <div class="encounter-header">
                        <h3>⚔️ Encounter Builder</h3>
                        <div class="encounter-actions">
                            <button id="newEncounterBtn" class="new-encounter-btn">📋 New Encounter</button>
                            <button id="saveEncounterBtn" class="save-encounter-btn">💾 Save Encounter</button>
                            <button id="loadEncounterBtn" class="load-encounter-btn">📁 Load Encounter</button>
                        </div>
                    </div>
                    <div class="current-encounter-info">
                        <input type="text" id="encounterNameInput" placeholder="Enter encounter name..." class="encounter-name-input">
                        <button id="addEnemyBtn" class="add-enemy-btn">➕ Add Enemy</button>
                    </div>
                    <div id="encounterList" class="encounter-list">
                        <div class="empty-state">No encounter loaded. Click "New Encounter" to get started!</div>
                    </div>
                </div>
            </div>
            
            <div id="initiativeTab" class="tab-content">
                <div class="initiative-tracker-container">
                    <div class="initiative-header">
                        <h3>🎲 Initiative Tracker</h3>
                        <div class="initiative-controls">
                            <div class="round-counter">
                                <span class="round-label">Round:</span>
                                <span id="roundCounter" class="round-number">1</span>
                            </div>
                            <button id="prevTurnBtn" class="turn-btn prev-turn">⬅️ Previous</button>
                            <button id="nextTurnBtn" class="turn-btn next-turn">Next ➡️</button>
                        </div>
                    </div>
                    <div class="initiative-actions">
                        <button id="addPartyBtn" class="initiative-action-btn add-party">👥 Add Party</button>
                        <button id="addEncounterToInitiativeBtn" class="initiative-action-btn add-encounter">⚔️ Add Encounter</button>
                        <button id="addNoteBtn" class="initiative-action-btn add-note">📝 Add Note</button>
                        <button id="clearInitiativeBtn" class="initiative-action-btn clear-initiative">🗑️ Clear All</button>
                    </div>
                    <div id="initiativeList" class="initiative-list">
                        <div class="empty-state">No combatants in initiative. Add party members or encounters to get started!</div>
                    </div>
                </div>
            </div>

            <div id="battlemapTab" class="tab-content">
                <div class="battlemap-container">
                    <div class="battlemap-header">
                        <h3>🗺️ Battlemap</h3>
                        <div class="battlemap-actions">
                            <button id="selectLocationBtn" class="battlemap-action-btn">📍 Select Background</button>
                            <button id="clearBattlemapBtn" class="battlemap-action-btn clear-battlemap">🗑️ Clear Map</button>
                        </div>
                    </div>
                    <div class="battlemap-config">
                        <div class="grid-config">
                            <div class="grid-dimension-controls">
                                <div class="grid-size-input">
                                    <label for="gridWidth">Grid Width:</label>
                                    <input type="number" id="gridWidth" min="5" max="50" value="20" onchange="updateBattlemapGrid()">
                                </div>
                                <div class="grid-size-input">
                                    <label for="gridHeight">Grid Height:</label>
                                    <input type="number" id="gridHeight" min="5" max="50" value="15" disabled readonly>
                                    <small style="color: #bbb; margin-left: 8px;">(Auto from image)</small>
                                </div>
                                <div id="aspectRatioInfo" class="aspect-ratio-info">
                                    <small>Image ratio: <span id="imageRatio">Select background first</span></small>
                                </div>
                            </div>
                            <button id="saveBattlemapBtn" class="battlemap-action-btn">💾 Save Map</button>
                            <button id="toggleBattlemapDisplay" class="battlemap-action-btn">📺 Show on Display</button>
                            <div class="zoom-controls">
                                <button id="zoomOutBtn" class="battlemap-action-btn" onclick="zoomOut()">🔍- Zoom Out</button>
                                <button id="resetZoomBtn" class="battlemap-action-btn" onclick="resetZoom()">🎯 Reset View</button>
                                <button id="zoomInBtn" class="battlemap-action-btn" onclick="zoomIn()">🔍+ Zoom In</button>
                            </div>
                            <div class="focus-controls">
                                <button class="battlemap-action-btn" onclick="openCharacterFocusModal()">🎯 Focus Character</button>
                                <button class="battlemap-action-btn" onclick="panCenter()">📍 Center Map</button>
                            </div>
                        </div>
                    </div>
                    <div id="battlemapContainer" class="battlemap-grid-container">
                        <div class="empty-state">Select a location background to start building your battlemap!</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="live-panel">
            <h2>🖥️ Live Display</h2>
            
            <div class="display-section portraits">
                <h3>👥 Portraits</h3>
                <div id="portraitsList">
                    <div class="empty-state">No portraits displayed</div>
                </div>
                <button class="clear-btn" onclick="clearDisplayElement('portraits')" style="width: 100%; margin-top: 10px;">Clear All Portraits</button>
            </div>
            
            <div class="display-section background">
                <h3>🖼️ Background</h3>
                <div id="backgroundDisplay">
                    <div class="empty-state">No background set</div>
                </div>
            </div>
            
            <div class="display-section event">
                <h3>🎬 Current Event</h3>
                <div id="eventDisplay">
                    <div class="empty-state">No event playing</div>
                </div>
            </div>
            
            <div class="display-section audio">
                <h3>🔄 Background Sounds</h3>
                <div id="backgroundSoundDisplay">
                    <div class="empty-state">No background sounds</div>
                </div>
            </div>
            
            <div class="display-section audio">
                <h3>🎵 Background Music</h3>
                <div id="backgroundMusicDisplay">
                    <div class="empty-state">No background music</div>
                </div>
            </div>
            
            <div class="display-section audio">
                <h3>🔊 Sound Effects</h3>
                <div id="soundEffectsDisplay">
                    <div class="empty-state">No active sound effects</div>
                </div>
            </div>
            
            <button class="clear-all-btn" onclick="clearDisplayElement('all')">🗑️ Clear Entire Display</button>
        </div>

    <!-- Audio Players -->
    <div class="audio-container" style="display: none;">
        <div id="backgroundSoundsContainer"></div>
        <audio id="backgroundMusicPlayer" loop></audio>
        <div id="soundEffectsContainer"></div>
    </div>

    <!-- Portrait Selection Modal -->
    <div id="portraitModal" class="portrait-modal">
        <div class="portrait-modal-content">
            <div class="portrait-modal-header">
                <h3 class="portrait-modal-title">Select Character Portrait</h3>
                <button class="close-modal-btn" onclick="closePortraitModal()">✕</button>
            </div>
            <div class="portrait-search-container">
                <input type="text" id="portraitSearchInput" class="portrait-search-input" 
                       placeholder="🔍 Search portraits by name..." 
                       oninput="filterPortraits(this.value)">
                <div id="portraitSearchInfo" class="portrait-search-info">
                    Press '/' to focus search • Enter to select first result • Esc to close
                </div>
            </div>
            <div id="portraitGrid" class="portrait-grid">
                <!-- Portrait options will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Enemy Portrait Selection Modal -->
    <div id="enemyPortraitModal" class="portrait-modal">
        <div class="portrait-modal-content">
            <div class="portrait-modal-header">
                <h3 class="portrait-modal-title">Select Enemy Portrait</h3>
                <button class="close-modal-btn" onclick="closeEnemyPortraitModal()">✕</button>
            </div>
            <div class="portrait-search-container">
                <input type="text" id="enemyPortraitSearchInput" class="portrait-search-input" 
                       placeholder="🔍 Search portraits by name..." 
                       oninput="filterEnemyPortraits(this.value)">
                <div id="enemyPortraitSearchInfo" class="portrait-search-info">
                    Press '/' to focus search • Enter to select first result • Esc to close
                </div>
            </div>
            <div id="enemyPortraitGrid" class="portrait-grid">
                <!-- Enemy portrait options will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Encounter Selection Modal -->
    <div id="encounterSelectionModal" class="encounter-modal">
        <div class="encounter-modal-content">
            <div class="encounter-modal-header">
                <h3 class="encounter-modal-title">Load Encounter</h3>
                <button class="close-modal-btn" onclick="closeEncounterSelectionModal()">✕</button>
            </div>
            <div id="encounterListContainer" class="encounter-list-container">
                <!-- Encounter list will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Add Note Modal -->
    <div id="noteModal" class="note-modal">
        <div class="note-modal-content">
            <div class="note-modal-header">
                <h3 class="note-modal-title">Add Initiative Note</h3>
                <button class="close-modal-btn" onclick="closeNoteModal()">✕</button>
            </div>
            <form class="note-form" onsubmit="addInitiativeNote(event)">
                <div class="note-field">
                    <label>Initiative</label>
                    <input type="number" id="noteInitiative" placeholder="Enter initiative value" required min="0" max="50">
                </div>
                <div class="note-field">
                    <label>Note Title</label>
                    <input type="text" id="noteTitle" placeholder="Enter note title" required>
                </div>
                <div class="note-field">
                    <label>Description (optional)</label>
                    <textarea id="noteDescription" placeholder="Enter additional details..."></textarea>
                </div>
                <div class="note-modal-actions">
                    <button type="button" class="note-modal-btn note-cancel-btn" onclick="closeNoteModal()">Cancel</button>
                    <button type="submit" class="note-modal-btn note-add-btn">Add Note</button>
                </div>
            </form>
        </div>
    </div>

    <!-- HP Modal -->
    <div id="hpModal" class="modal">
        <div class="modal-content hp-modal">
            <div class="modal-header">
                <h3 id="hpModalTitle">Adjust HP</h3>
                <span class="close" onclick="closeHPModal()">&times;</span>
            </div>
            <div id="hpModalContent">
                <div class="form-group">
                    <label for="hpAmount">Amount:</label>
                    <input type="number" id="hpAmount" min="1" max="999" placeholder="Enter amount" required>
                    <small style="color: #999; font-size: 12px; display: block; margin-top: 5px;">
                        Enter = Apply Damage | Shift+Enter = Apply Healing
                    </small>
                </div>
                <div class="current-hp-display">
                    <span id="currentHPDisplay">Current HP: 0/0</span>
                </div>
                <div class="hp-modal-actions">
                    <button class="damage-btn" onclick="applyHPChange('damage')">Apply Damage</button>
                    <button class="heal-btn" onclick="applyHPChange('heal')">Apply Healing</button>
                </div>
                <div class="modal-actions">
                    <button type="button" class="secondary-btn" onclick="closeHPModal()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Enemy Info Modal -->
    <div id="enemyInfoModal" class="modal">
        <div class="modal-content enemy-info-modal">
            <div class="modal-header">
                <h3 id="enemyInfoTitle">Enemy Details</h3>
                <span class="close" onclick="closeEnemyInfoModal()">&times;</span>
            </div>
            <div id="enemyInfoContent">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Battlemap Token Selection Modal -->
    <div id="battlemapTokenModal" class="portrait-modal">
        <div class="portrait-modal-content">
            <div class="portrait-modal-header">
                <h3 class="portrait-modal-title">Add Character to Battlemap</h3>
                <button class="close-modal-btn" onclick="closeBattlemapTokenModal()">✕</button>
            </div>
            <div class="portrait-search-container">
                <input type="text" id="battlemapTokenSearchInput" class="portrait-search-input" 
                       placeholder="🔍 Search characters by name..." 
                       oninput="filterBattlemapTokens(this.value)">
                <div class="portrait-search-info">
                    Press '/' to focus search • Enter to select first result • Esc to close
                </div>
            </div>
            <div id="battlemapTokenGrid" class="portrait-grid">
                <!-- Token options will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Battlemap Background Selection Modal -->
    <div id="battlemapBackgroundModal" class="portrait-modal">
        <div class="portrait-modal-content">
            <div class="portrait-modal-header">
                <h3 class="portrait-modal-title">Select Battlemap Background</h3>
                <button class="close-modal-btn" onclick="closeBattlemapBackgroundModal()">✕</button>
            </div>
            <div class="portrait-search-container">
                <input type="text" id="battlemapBackgroundSearchInput" class="portrait-search-input" 
                       placeholder="🔍 Search locations by name..." 
                       oninput="filterBattlemapBackgrounds(this.value)">
                <div class="portrait-search-info">
                    Press '/' to focus search • Enter to select first result • Esc to close
                </div>
            </div>
            <div id="battlemapBackgroundGrid" class="portrait-grid">
                <!-- Background options will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Character Focus Modal -->
    <div id="characterFocusModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Focus on Character</h3>
                <button class="close" onclick="closeCharacterFocusModal()">✕</button>
            </div>
            <div class="character-focus-content">
                <div class="character-list" id="characterFocusList">
                    <!-- Characters will be populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <!-- Battlemap Context Menu -->
    <div id="battlemapContextMenu" class="battlemap-context-menu">
        <!-- Context menu items will be populated dynamically -->
    </div>

    <script>
        let currentDirectory = null;
        let fileStructure = null;
        let currentPath = []; // Initialize as empty array
        let currentAudioPath = []; // Track audio navigation separately
        
        // Tab switching functionality
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Add active class to clicked button
            event.target.classList.add('active');
            
            // Re-render audio list when switching to audio tab
            if (tabName === 'audio' && fileStructure) {
                console.log('Switching to audio tab, re-rendering audio list...');
                setTimeout(() => {
                    renderAudioLists(fileStructure, currentAudioPath);
                }, 50);
            }
            
            // Load party data when switching to party tab
            if (tabName === 'party') {
                loadPartyData();
            }
            
            // Load encounter data when switching to encounters tab
            if (tabName === 'encounters') {
                // No need to auto-load, user will select
            }

            // Initialize battlemap when switching to battlemap tab
            if (tabName === 'battlemap') {
                // Ensure file structure is loaded before initializing battlemap
                if (!fileStructure || !fileStructure.children) {
                    console.log('File structure not loaded, loading it first...');
                    loadFileStructure().then(() => {
                        setTimeout(() => {
                            generateBattlemapGrid();
                        }, 100);
                    });
                } else {
                    setTimeout(() => {
                        generateBattlemapGrid();
                    }, 50);
                }
            }
        }

        // Get the cached directory and initialize dashboard
        async function initializeDashboard() {
            try {
                currentDirectory = await window.electronAPI.getCachedDirectory();
                if (currentDirectory) {
                    loadFileStructure();
                    loadDisplayState();
                    loadInitiativeState();
                    loadBattlemapData();
                } else {
                    // If no cached directory, prompt for one
                    document.getElementById('fileExplorer').innerHTML = 
                        '<div class="error">No directory found. Please select a directory to continue.</div>' +
                        '<button onclick="selectNewDirectory()" style="margin-top: 20px;">📁 Select Directory</button>';
                }
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                document.getElementById('fileExplorer').innerHTML = 
                    '<div class="error">Error initializing dashboard: ' + error.message + '</div>';
            }
        }

        async function selectNewDirectory() {
            try {
                const directory = await window.electronAPI.selectDirectory();
                if (directory) {
                    currentDirectory = directory;
                    loadFileStructure();
                    loadInitiativeState();
                    loadBattlemapData();
                }
            } catch (error) {
                console.error('Error selecting directory:', error);
                alert('Error selecting directory: ' + error.message);
            }
        }

        async function loadFileStructure() {
            try {
                if (!currentDirectory) {
                    document.getElementById('mediaGrid').innerHTML = 
                        '<div class="error">No directory selected.</div>';
                    return;
                }

                document.getElementById('mediaGrid').innerHTML = '<div class="loading">Scanning directory...</div>';
                
                fileStructure = await window.electronAPI.scanDirectory(currentDirectory);
                
                // Render both interfaces
                console.log('File structure loaded:', fileStructure); // Debug log
                renderMediaGrid(fileStructure, currentPath);
                
                // Add a small delay before rendering audio to ensure DOM is ready
                setTimeout(() => {
                    console.log('Rendering audio lists with delay...');
                    renderAudioLists(fileStructure, currentAudioPath);
                }, 100);
                
            } catch (error) {
                console.error('Error loading file structure:', error);
                document.getElementById('mediaGrid').innerHTML = 
                    `<div class="error">Error loading files: ${error.message}</div>`;
            }
        }
        
        // Helper function to check if a folder contains images or videos (recursively)
        function folderContainsMedia(folderItem) {
            if (!folderItem.children || !Array.isArray(folderItem.children)) {
                return false;
            }
            
            for (const child of folderItem.children) {
                if (child.type === 'file' && (child.mediaType === 'image' || child.mediaType === 'video')) {
                    return true;
                }
                if (child.type === 'folder' && folderContainsMedia(child)) {
                    return true;
                }
            }
            return false;
        }
        
        // Generate clickable breadcrumbs with custom navigation function
        function generateBreadcrumbs(path, navigationFunction = 'navigateToPath') {
            let breadcrumbs = [];
            
            // Add root
            breadcrumbs.push(`
                <span class="breadcrumb-item" onclick="${navigationFunction}([])">Root</span>
            `);
            
            // Add each path segment
            for (let i = 0; i < path.length; i++) {
                const segment = path[i];
                const segmentPath = path.slice(0, i + 1);
                
                breadcrumbs.push(`
                    <span class="breadcrumb-separator">></span>
                    <span class="breadcrumb-item" onclick="${navigationFunction}([${segmentPath.map(p => `'${p}'`).join(',')}])">${segment}</span>
                `);
            }
            
            return breadcrumbs.join('');
        }

        // Clean up filename for display
        function cleanFileName(filename) {
            if (!filename) return '';
            
            // Remove file extension
            let cleaned = filename.replace(/\.[^/.]+$/, '');
            
            // Remove common suffixes
            cleaned = cleaned.replace(/_location$/, '');
            cleaned = cleaned.replace(/_bg$/, '');
            cleaned = cleaned.replace(/_background$/, '');
            cleaned = cleaned.replace(/_portrait$/, '');
            cleaned = cleaned.replace(/_event$/, '');
            
            // Replace underscores with spaces
            cleaned = cleaned.replace(/_/g, ' ');
            
            // Capitalize first letter of each word
            cleaned = cleaned.split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');
            
            // Handle leading underscore case (for portraits that start with _)
            if (filename.startsWith('_')) {
                return cleaned || '???';
            }
            
            return cleaned || filename;
        }

        // Sort media items by type: folders, bg images, bg videos, portraits, events
        function getMediaSortOrder(item) {
            switch (item.type) {
                case 'back':
                    return -1; // Back button first
                case 'folder':
                    return 0; // Folders first
                case 'background':
                    return 1; // Background images second
                case 'background-video':
                    return 2; // Background videos third
                case 'portrait':
                    return 3; // Portraits fourth
                case 'event':
                    return 4; // Events fifth
                case 'image':
                    return 5; // Other images
                default:
                    return 6; // Everything else
            }
        }

        // New media grid rendering
        function renderMediaGrid(item, path = []) {
            const mediaGrid = document.getElementById('mediaGrid');
            const currentPathEl = document.getElementById('currentPath');
            
            console.log('renderMediaGrid called with:', item, path); // Debug log
            
            if (!item) {
                mediaGrid.innerHTML = '<div class="loading">No media files found</div>';
                return;
            }
            
            // Update breadcrumbs
            currentPathEl.innerHTML = generateBreadcrumbs(path, 'navigateToPath');
            
            let allItems = [];
            
            // Add back button if not at root
            if (path.length > 0) {
                allItems.push({
                    type: 'back',
                    name: '← Back',
                    path: path.slice(0, -1),
                    isBack: true
                });
            }
            
            // Process children array
            if (item.children && Array.isArray(item.children)) {
                console.log('Processing children array:', item.children); // Debug log
                item.children.forEach((child, index) => {
                    console.log(`Child ${index}:`, child); // Debug log
                    
                    if (child.type === 'folder') {
                        // Only include folders that contain images or videos
                        if (folderContainsMedia(child)) {
                            allItems.push({
                                type: 'folder',
                                name: child.name,
                                child: child,
                                path: [...path, child.name]
                            });
                        }
                    } else if (child.type === 'file') {
                        // Only include images and videos, filter out audio
                        if (child.mediaType === 'image' || child.mediaType === 'video') {
                            let itemType = 'file';
                            let icon = '📄';
                            let badge = 'FILE';
                            
                            if (child.mediaType === 'image') {
                                if (child.name.startsWith('_') || child.mediaSubtype === 'portrait') {
                                    itemType = 'portrait';
                                    icon = '👤';
                                    badge = 'PORTRAIT';
                                } else if (child.name.includes('_location') || child.mediaSubtype === 'background') {
                                    itemType = 'background';
                                    icon = '🖼️';
                                    badge = 'BACKGROUND';
                                } else {
                                    itemType = 'image';
                                    icon = '🖼️';
                                    badge = 'IMAGE';
                                }
                            } else if (child.mediaType === 'video') {
                                if (child.name.includes('_location') || child.mediaSubtype === 'background') {
                                    itemType = 'background-video';
                                    icon = '🎥';
                                    badge = 'BACKGROUND';
                                } else {
                                    itemType = 'event';
                                    icon = '🎬';
                                    badge = 'EVENT';
                                }
                            }
                            
                            allItems.push({
                                type: itemType,
                                name: child.name,
                                displayName: cleanFileName(child.name),
                                child: child,
                                icon: icon,
                                badge: badge,
                                path: [...path, child.name]
                            });
                        }
                    }
                });
            }
            
            console.log('Total items to render (after filtering):', allItems.length); // Debug log
            console.log('Filtered items:', allItems); // Debug log
            
            // Sort items by type: folders, backgrounds, portraits, events
            allItems.sort((a, b) => {
                const aOrder = getMediaSortOrder(a);
                const bOrder = getMediaSortOrder(b);
                
                if (aOrder !== bOrder) {
                    return aOrder - bOrder;
                }
                
                // Within the same category, sort alphabetically
                return a.name.localeCompare(b.name);
            });
            
            console.log('Items after sorting:', allItems); // Debug log
            
            // Render all items in a single grid
            if (allItems.length === 0 || (allItems.length === 1 && allItems[0].isBack)) {
                mediaGrid.innerHTML = `
                    ${allItems.length === 1 && allItems[0].isBack ? `
                        <div class="media-grid-section">
                            <div class="media-item folder" onclick="navigateToPath([${allItems[0].path.map(p => `'${p}'`).join(',')}])">
                                <div class="media-icon">↩️</div>
                                <div class="media-name">${allItems[0].name}</div>
                            </div>
                        </div>
                    ` : ''}
                    <div class="empty-state">No images or videos found in this directory</div>
                `;
                return;
            }
            
            mediaGrid.innerHTML = `
                <div class="media-grid-section">
                    ${allItems.map(item => {
                        if (item.isBack) {
                            return `
                                <div class="media-item folder" onclick="navigateToPath([${item.path.map(p => `'${p}'`).join(',')}])">
                                    <div class="media-icon">↩️</div>
                                    <div class="media-name">${item.name}</div>
                                </div>
                            `;
                        } else if (item.type === 'folder') {
                            return `
                                <div class="media-item folder" onclick="navigateToPath([${item.path.map(p => `'${p}'`).join(',')}])">
                                    <div class="type-badge">FOLDER</div>
                                    <div class="media-icon">📁</div>
                                    <div class="media-name">${item.name}</div>
                                </div>
                            `;
                        } else {
                            // Handle all file types (now only images and videos)
                            const isImage = item.child.mediaType === 'image';
                            const clickAction = `onclick="displayMedia('${item.child.path}', '${item.child.mediaType}', '${item.child.mediaSubtype || item.type}', '${item.displayName}')"`;
                                
                            return `
                                <div class="media-item ${item.type}" ${clickAction}>
                                    <div class="type-badge">${item.badge}</div>
                                    ${isImage ? 
                                        `<img class="media-preview" src="file://${item.child.path}" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                         <div class="media-icon" style="display: none;">${item.icon}</div>` :
                                        `<div class="media-icon">${item.icon}</div>`
                                    }
                                    <div class="media-name">${item.displayName}</div>
                                </div>
                            `;
                        }
                    }).join('')}
                </div>
            `;
        }
        
        // Common navigation function that handles path navigation for both tabs
        function navigateToDirectory(newPath, callback) {
            console.log('navigateToDirectory called with path:', newPath, 'fileStructure:', fileStructure);
            
            // Get current directory structure
            let currentItem = fileStructure;
            for (const segment of newPath) {
                console.log('Looking for segment:', segment, 'in currentItem:', currentItem);
                if (currentItem && currentItem.children) {
                    const found = currentItem.children.find(item => item.name === segment);
                    if (found) {
                        currentItem = found;
                        console.log('Found segment:', segment, 'result:', found);
                    } else {
                        console.log('Could not find segment:', segment, 'in', currentItem.children?.map(c => c.name));
                        // Reset to root on failure
                        currentItem = fileStructure;
                        newPath = [];
                        break;
                    }
                } else {
                    console.log('No children found in currentItem:', currentItem);
                    currentItem = fileStructure;
                    newPath = [];
                    break;
                }
            }
            
            console.log('Navigation result - currentItem:', currentItem, 'path:', newPath);
            
            // Execute callback with the result
            if (callback) {
                callback(currentItem, newPath);
            }
        }

        // Media grid navigation wrapper
        function navigateToPath(newPath) {
            currentPath = newPath;
            navigateToDirectory(newPath, (currentItem, actualPath) => {
                currentPath = actualPath;
                renderMediaGrid(currentItem, currentPath);
            });
        }
        
        // Helper function to check if folder contains audio files
        function folderContainsAudio(folder) {
            if (!folder.children || !Array.isArray(folder.children)) {
                return false;
            }
            
            for (const child of folder.children) {
                if (child.type === 'file' && child.mediaType === 'audio') {
                    return true;
                }
                if (child.type === 'folder' && folderContainsAudio(child)) {
                    return true;
                }
            }
            
            return false;
        }

        // Get audio sort order
        function getAudioSortOrder(item) {
            switch (item.type) {
                case 'back':
                    return -1; // Back button first
                case 'folder':
                    return 0; // Folders first
                case 'music':
                    return 1; // Music second
                case 'loop':
                    return 2; // Loops third
                case 'sound':
                    return 3; // Sound effects fourth
                default:
                    return 4; // Everything else
            }
        }

        // Audio list rendering with navigation
        function renderAudioLists(structure, path = []) {
            console.log('Rendering audio lists for path:', path, 'Structure:', structure);
            
            // Update unified audio container
            const audioList = document.getElementById('audioList');
            console.log('AudioList element found:', audioList);
            
            if (!audioList) {
                console.error('audioList element not found!');
                return;
            }
            
            // Check if audio tab is visible
            const audioTab = document.getElementById('audioTab');
            const isVisible = audioTab && !audioTab.classList.contains('hidden') && audioTab.offsetParent !== null;
            console.log('Audio tab visible:', isVisible, 'audioTab element:', audioTab);
            
            // Clear list first
            audioList.innerHTML = '';
            console.log('Cleared audioList innerHTML');

            // Generate breadcrumbs for audio tab
            const breadcrumbsHtml = generateBreadcrumbs(path, 'navigateToAudioPath');
            const breadcrumbsContainer = document.createElement('div');
            breadcrumbsContainer.className = 'breadcrumbs audio-breadcrumbs';
            breadcrumbsContainer.innerHTML = breadcrumbsHtml;
            
            // Add breadcrumbs to the list container
            audioList.appendChild(breadcrumbsContainer);

            // Use the structure directly (no need to navigate again)
            const currentDir = structure;

            if (!currentDir || !currentDir.children) {
                console.log('No children found for current directory');
                audioList.innerHTML += '<div class="empty-state">No files found in this directory</div>';
                return;
            }

            console.log('Current directory children for audio:', currentDir.children);            // Collect all audio items
            let allItems = [];
            
            // Add back button if not at root
            if (path.length > 0) {
                allItems.push({
                    type: 'back',
                    name: '← Back',
                    path: path.slice(0, -1),
                    isBack: true
                });
            }

            // Filter and categorize items (only directories with audio and audio files)
            currentDir.children.forEach((item, index) => {
                console.log(`Processing audio item ${index}:`, item);
                
                if (item.type === 'folder') {
                    if (folderContainsAudio(item)) {
                        console.log('Folder contains audio:', item.name);
                        allItems.push({
                            type: 'folder',
                            name: item.name,
                            child: item,
                            path: [...path, item.name]
                        });
                    } else {
                        console.log('Folder does not contain audio:', item.name);
                    }
                } else if (item.type === 'file') {
                    console.log('File found:', item.name, 'mediaType:', item.mediaType);
                    
                    if (item.mediaType === 'audio') {
                        console.log('Audio file found:', item.name);
                        
                        let itemType = 'sound'; // default
                        let icon = '🔊';
                        let badge = 'SFX';
                        
                        const name = item.name.toLowerCase();
                        
                        // Determine audio type based on filename or mediaSubtype
                        if (item.mediaSubtype === 'music' || name.includes('music') || name.includes('song') || name.includes('theme')) {
                            itemType = 'music';
                            icon = '🎵';
                            badge = 'MUSIC';
                        } else if (item.mediaSubtype === 'loop' || name.includes('loop') || name.includes('ambient') || name.includes('background')) {
                            itemType = 'loop';
                            icon = '🔄';
                            badge = 'LOOP';
                        }
                        
                        allItems.push({
                            type: itemType,
                            name: item.name,
                            displayName: cleanFileName(item.name),
                            child: item,
                            icon: icon,
                            badge: badge,
                            path: [...path, item.name]
                        });
                    }
                }
            });

            console.log('Total audio items found:', allItems.length);
            console.log('Audio items to render:', allItems);

            // Sort items by type
            allItems.sort((a, b) => {
                const aOrder = getAudioSortOrder(a);
                const bOrder = getAudioSortOrder(b);
                
                if (aOrder !== bOrder) {
                    return aOrder - bOrder;
                }
                
                // Within the same category, sort alphabetically
                return a.name.localeCompare(b.name);
            });

            console.log('Audio items after sorting:', allItems);

            // Render items in unified container
            if (allItems.length === 0 || (allItems.length === 1 && allItems[0].isBack)) {
                console.log('No audio items to render, showing empty state');
                audioList.innerHTML += `
                    ${allItems.length === 1 && allItems[0].isBack ? `
                        <div class="audio-file-item back-item" onclick="navigateToAudioPath([${allItems[0].path.map(p => `'${p}'`).join(',')}])">
                            <div class="audio-icon">↩️</div>
                            <div class="audio-name">${allItems[0].name}</div>
                        </div>
                    ` : ''}
                    <div class="empty-state">No audio files found in this directory</div>
                `;
                return;
            }

            console.log('Generating HTML for', allItems.length, 'audio items');
            const itemsHtml = allItems.map((item, index) => {
                console.log(`Generating HTML for item ${index}:`, item);
                
                if (item.isBack) {
                    return `
                        <div class="audio-file-item back-item" onclick="navigateToAudioPath([${item.path.map(p => `'${p}'`).join(',')}])">
                            <div class="audio-icon">↩️</div>
                            <div class="audio-name">${item.name}</div>
                        </div>
                    `;
                } else if (item.type === 'folder') {
                    return `
                        <div class="audio-file-item folder-item" onclick="navigateToAudioPath([${item.path.map(p => `'${p}'`).join(',')}])">
                            <div class="audio-icon">📁</div>
                            <div class="audio-name">${item.name}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="audio-file-item ${item.type}" onclick="playAudio('${item.child.path}', '${item.type}', '${item.displayName}')">
                            <div class="audio-icon">${item.icon}</div>
                            <div class="audio-name">${item.displayName}</div>
                            <div class="audio-badge">${item.badge}</div>
                        </div>
                    `;
                }
            }).join('');

            console.log('Generated HTML length:', itemsHtml.length);
            console.log('Generated HTML preview:', itemsHtml.substring(0, 200));
            
            audioList.innerHTML += itemsHtml;
            
            console.log('Final audioList innerHTML length:', audioList.innerHTML.length);
            console.log('AudioList element:', audioList);
        }

        // Audio navigation wrapper  
        function navigateToAudioPath(newPath) {
            console.log('navigateToAudioPath called with:', newPath);
            currentAudioPath = newPath;
            navigateToDirectory(newPath, (currentItem, actualPath) => {
                console.log('Audio navigation callback - currentItem:', currentItem, 'actualPath:', actualPath);
                currentAudioPath = actualPath;
                renderAudioLists(currentItem, currentAudioPath);
            });
        }

        function playAudio(path, subtype, displayName) {
            window.electronAPI.displayMedia(path, 'audio', subtype, displayName);
        }        function renderFileStructure(item, container = null, depth = 0) {
            if (!container) {
                container = document.getElementById('fileExplorer');
                container.innerHTML = '';
            }

            const element = document.createElement('div');
            
            if (item.type === 'folder') {
                element.className = 'folder-item';
                element.innerHTML = `
                    <span class="folder-icon">📁</span>
                    <span>${item.name}</span>
                `;
                
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'folder-children';
                childrenContainer.style.display = 'none';
                
                element.addEventListener('click', () => {
                    const isOpen = childrenContainer.style.display !== 'none';
                    childrenContainer.style.display = isOpen ? 'none' : 'block';
                    element.classList.toggle('open', !isOpen);
                    element.querySelector('.folder-icon').textContent = isOpen ? '📁' : '📂';
                });
                
                container.appendChild(element);
                container.appendChild(childrenContainer);
                
                // Render children
                item.children.forEach(child => {
                    renderFileStructure(child, childrenContainer, depth + 1);
                });
                
            } else if (item.type === 'file') {
                element.className = `file-item ${item.mediaType} ${item.mediaSubtype}`;
                
                let icon = '📄';
                let typeLabel = '';
                
                switch (item.mediaType) {
                    case 'image':
                        if (item.mediaSubtype === 'portrait') {
                            icon = '👤';
                            typeLabel = ' (Portrait)';
                        } else if (item.mediaSubtype === 'background') {
                            icon = '🖼️';
                            typeLabel = ' (Background)';
                        }
                        break;
                    case 'video':
                        if (item.mediaSubtype === 'event') {
                            icon = '🎬';
                            typeLabel = ' (Event)';
                        } else if (item.mediaSubtype === 'background') {
                            icon = '🎥';
                            typeLabel = ' (Video BG)';
                        }
                        break;
                    case 'audio':
                        if (item.mediaSubtype === 'sound') {
                            icon = '🔊';
                            typeLabel = ' (SFX)';
                        } else if (item.mediaSubtype === 'loop') {
                            icon = '🔄';
                            typeLabel = ' (Loop)';
                        } else if (item.mediaSubtype === 'music') {
                            icon = '🎵';
                            typeLabel = ' (Music)';
                        }
                        break;
                }
                
                element.innerHTML = `
                    <span class="file-icon">${icon}</span>
                    <span>${item.displayName}${typeLabel}</span>
                `;
                
                element.addEventListener('click', () => {
                    displayMedia(item.path, item.mediaType, item.mediaSubtype, item.displayName);
                });
                
                container.appendChild(element);
            }
        }

        async function displayMedia(path, type, subtype, displayName) {
            try {
                await window.electronAPI.displayMedia(path, type, subtype, displayName);
            } catch (error) {
                console.error('Error displaying media:', error);
                alert('Error displaying media: ' + error.message);
            }
        }

        async function clearDisplayElement(elementType, elementPath = null) {
            try {
                await window.electronAPI.clearDisplayElement(elementType, elementPath);
            } catch (error) {
                console.error('Error clearing display element:', error);
            }
        }

        function updateDisplayPanel(displayState) {
            // Update portraits
            const portraitsList = document.getElementById('portraitsList');
            if (displayState.portraits && displayState.portraits.length > 0) {
                portraitsList.innerHTML = displayState.portraits.map((portrait, index) => `
                    <div class="display-item">
                        <span>👤 ${portrait.displayName}</span>
                        <button class="clear-btn" onclick="clearSpecificPortrait(${index})">×</button>
                    </div>
                `).join('');
            } else {
                portraitsList.innerHTML = '<div class="empty-state">No portraits displayed</div>';
            }

            // Update background
            const backgroundDisplay = document.getElementById('backgroundDisplay');
            if (displayState.background) {
                const bg = displayState.background;
                const icon = bg.type === 'video' ? '🎥' : '🖼️';
                backgroundDisplay.innerHTML = `
                    <div class="display-item">
                        <span>${icon} ${bg.displayName}</span>
                        <button class="clear-btn" onclick="clearDisplayElement('background')">×</button>
                    </div>
                `;
            } else {
                backgroundDisplay.innerHTML = '<div class="empty-state">No background set</div>';
            }

            // Update event
            const eventDisplay = document.getElementById('eventDisplay');
            if (displayState.event) {
                eventDisplay.innerHTML = `
                    <div class="display-item">
                        <span>🎬 ${displayState.event.displayName}</span>
                        <button class="clear-btn" onclick="clearDisplayElement('event')">×</button>
                    </div>
                `;
            } else {
                eventDisplay.innerHTML = '<div class="empty-state">No event playing</div>';
            }

            // Update background sounds
            const backgroundSoundDisplay = document.getElementById('backgroundSoundDisplay');
            if (displayState.backgroundSounds && displayState.backgroundSounds.length > 0) {
                backgroundSoundDisplay.innerHTML = displayState.backgroundSounds.map(sound => `
                    <div class="display-item">
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span>🔄 ${sound.displayName}</span>
                                <button class="clear-btn" onclick="clearDisplayElement('backgroundSound', '${sound.id}')">×</button>
                            </div>
                            <div class="volume-control">
                                <span class="volume-label">Vol:</span>
                                <input type="range" class="volume-slider" min="0" max="100" value="70" 
                                       onchange="updateAudioVolume('backgroundSound_${sound.id}', this.value)">
                                <span class="volume-label">70%</span>
                            </div>
                        </div>
                    </div>
                `).join('');
            } else {
                backgroundSoundDisplay.innerHTML = '<div class="empty-state">No background sounds</div>';
            }

            // Update background music
            const backgroundMusicDisplay = document.getElementById('backgroundMusicDisplay');
            if (displayState.backgroundMusic) {
                backgroundMusicDisplay.innerHTML = `
                    <div class="display-item">
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span>🎵 ${displayState.backgroundMusic.displayName}</span>
                                <button class="clear-btn" onclick="clearDisplayElement('backgroundMusic')">×</button>
                            </div>
                            <div class="volume-control">
                                <span class="volume-label">Vol:</span>
                                <input type="range" class="volume-slider" min="0" max="100" value="50" 
                                       onchange="updateAudioVolume('backgroundMusicPlayer', this.value)">
                                <span class="volume-label">50%</span>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                backgroundMusicDisplay.innerHTML = '<div class="empty-state">No background music</div>';
            }

            // Update sound effects
            const soundEffectsDisplay = document.getElementById('soundEffectsDisplay');
            if (displayState.soundEffects && displayState.soundEffects.length > 0) {
                soundEffectsDisplay.innerHTML = displayState.soundEffects.map(effect => `
                    <div class="display-item">
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span>🔊 ${effect.displayName}</span>
                                <button class="clear-btn" onclick="clearDisplayElement('soundEffect', '${effect.id}')">×</button>
                            </div>
                            <div class="volume-control">
                                <span class="volume-label">Vol:</span>
                                <input type="range" class="volume-slider" min="0" max="100" value="80" 
                                       onchange="updateAudioVolume('soundEffect_${effect.id}', this.value)">
                                <span class="volume-label">80%</span>
                            </div>
                        </div>
                    </div>
                `).join('');
            } else {
                soundEffectsDisplay.innerHTML = '<div class="empty-state">No active sound effects</div>';
            }
        }

        // Audio handling functions
        let currentSoundEffects = new Map(); // Track currently playing sound effects
        let currentBackgroundSounds = new Map(); // Track currently playing background sounds

        // Audio fade utilities
        function fadeIn(audioElement, duration = 2000) {
            if (audioElement.paused) return; // Don't fade if audio is paused
            
            audioElement.volume = 0;
            const targetVolume = audioElement.dataset.targetVolume ? parseFloat(audioElement.dataset.targetVolume) : 0.7;
            const fadeStep = targetVolume / (duration / 50); // 50ms intervals
            
            const fadeInterval = setInterval(() => {
                if (audioElement.paused) {
                    clearInterval(fadeInterval);
                    return;
                }
                
                if (audioElement.volume + fadeStep >= targetVolume) {
                    audioElement.volume = targetVolume;
                    clearInterval(fadeInterval);
                } else {
                    audioElement.volume += fadeStep;
                }
            }, 50);
            
            return fadeInterval;
        }

        function fadeOut(audioElement, duration = 2000) {
            return new Promise((resolve) => {
                if (audioElement.paused || audioElement.volume === 0) {
                    audioElement.volume = 0;
                    audioElement.pause();
                    resolve();
                    return;
                }
                
                const startVolume = audioElement.volume;
                const fadeStep = startVolume / (duration / 50); // 50ms intervals
                
                const fadeInterval = setInterval(() => {
                    if (audioElement.paused) {
                        clearInterval(fadeInterval);
                        resolve();
                        return;
                    }
                    
                    if (audioElement.volume - fadeStep <= 0) {
                        audioElement.volume = 0;
                        audioElement.pause();
                        clearInterval(fadeInterval);
                        resolve();
                    } else {
                        audioElement.volume -= fadeStep;
                    }
                }, 50);
            });
        }

        function updateBackgroundSounds(backgroundSounds) {
            const container = document.getElementById('backgroundSoundsContainer');
            const newSounds = backgroundSounds || [];
            
            // Convert array to Map for easier comparison
            const newSoundsMap = new Map();
            newSounds.forEach(sound => {
                newSoundsMap.set(sound.id, sound);
            });
            
            // Remove background sounds that are no longer in the state (with fade out)
            for (const [id, audioElement] of currentBackgroundSounds) {
                if (!newSoundsMap.has(id)) {
                    // Fade out and remove
                    fadeOut(audioElement).then(() => {
                        audioElement.remove();
                    });
                    currentBackgroundSounds.delete(id);
                }
            }
            
            // Add new background sounds that aren't already playing
            newSounds.forEach(sound => {
                if (!currentBackgroundSounds.has(sound.id)) {
                    // This is a new background sound, create and play it
                    const audio = document.createElement('audio');
                    audio.src = `file://${sound.path}`;
                    audio.dataset.targetVolume = '0.7'; // Store target volume for fade-in
                    audio.loop = true; // Background sounds should loop
                    audio.id = `backgroundSound_${sound.id}`;
                    
                    // Remove from both maps when sound ends (shouldn't happen with loop=true)
                    audio.addEventListener('ended', () => {
                        currentBackgroundSounds.delete(sound.id);
                        window.electronAPI.clearDisplayElement('backgroundSound', sound.id);
                    });
                    
                    audio.addEventListener('error', (e) => {
                        console.error('Error playing background sound:', e);
                        currentBackgroundSounds.delete(sound.id);
                        window.electronAPI.clearDisplayElement('backgroundSound', sound.id);
                    });
                    
                    container.appendChild(audio);
                    currentBackgroundSounds.set(sound.id, audio);
                    
                    // Start playing and fade in
                    audio.play().then(() => {
                        fadeIn(audio);
                    }).catch(e => console.error('Error playing background sound:', e));
                }
            });
        }

        function updateBackgroundSound(backgroundSound) {
            // Legacy function - now just calls updateBackgroundSounds with array
            updateBackgroundSounds(backgroundSound ? [backgroundSound] : []);
        }

        function updateBackgroundMusic(backgroundMusic) {
            const player = document.getElementById('backgroundMusicPlayer');
            
            if (backgroundMusic) {
                const newSrc = `file://${backgroundMusic.path}`;
                
                if (player.src !== newSrc) {
                    if (player.src && !player.paused) {
                        // Music is currently playing, fade out then switch
                        fadeOut(player).then(() => {
                            player.src = newSrc;
                            player.dataset.targetVolume = '0.5'; // Store target volume for music
                            player.play().then(() => {
                                fadeIn(player);
                            }).catch(e => console.error('Error playing background music:', e));
                        });
                    } else {
                        // No music currently playing, start new music with fade in
                        player.src = newSrc;
                        player.dataset.targetVolume = '0.5'; // Store target volume for music
                        player.play().then(() => {
                            fadeIn(player);
                        }).catch(e => console.error('Error playing background music:', e));
                    }
                }
            } else {
                if (!player.paused) {
                    // Fade out current music
                    fadeOut(player).then(() => {
                        player.src = '';
                    });
                } else {
                    player.src = '';
                }
            }
        }

        function updateSoundEffects(soundEffects) {
            const container = document.getElementById('soundEffectsContainer');
            const newEffects = soundEffects || [];
            
            // Convert array to Map for easier comparison
            const newEffectsMap = new Map();
            newEffects.forEach(effect => {
                newEffectsMap.set(effect.id, effect);
            });
            
            // Remove sound effects that are no longer in the state
            for (const [id, audioElement] of currentSoundEffects) {
                if (!newEffectsMap.has(id)) {
                    audioElement.remove();
                    currentSoundEffects.delete(id);
                }
            }
            
            // Add new sound effects that aren't already playing
            newEffects.forEach(effect => {
                if (!currentSoundEffects.has(effect.id)) {
                    // This is a new sound effect, create and play it
                    const audio = document.createElement('audio');
                    audio.src = `file://${effect.path}`;
                    audio.volume = 0.8; // Full volume for sound effects
                    audio.id = `soundEffect_${effect.id}`;
                    
                    // Remove from both maps when sound ends
                    audio.addEventListener('ended', () => {
                        currentSoundEffects.delete(effect.id);
                        window.electronAPI.clearDisplayElement('soundEffect', effect.id);
                    });
                    
                    audio.addEventListener('error', (e) => {
                        console.error('Error playing sound effect:', e);
                        currentSoundEffects.delete(effect.id);
                        window.electronAPI.clearDisplayElement('soundEffect', effect.id);
                    });
                    
                    container.appendChild(audio);
                    currentSoundEffects.set(effect.id, audio);
                    audio.play().catch(e => console.error('Error playing sound effect:', e));
                }
            });
        }

        // Track previous audio state to avoid unnecessary updates
        let previousAudioState = {
            backgroundSounds: [],
            backgroundMusic: null,
            soundEffects: []
        };

        function updateAudioIfChanged(displayState) {
            // Check if background sounds changed
            const currentBgSounds = displayState.backgroundSounds || [];
            const prevBgSounds = previousAudioState.backgroundSounds || [];
            if (!soundEffectsEqual(currentBgSounds, prevBgSounds)) {
                updateBackgroundSounds(currentBgSounds);
                previousAudioState.backgroundSounds = currentBgSounds;
            }

            // Check if background music changed
            const currentBgMusic = displayState.backgroundMusic;
            const prevBgMusic = previousAudioState.backgroundMusic;
            if (!audioStatesEqual(currentBgMusic, prevBgMusic)) {
                updateBackgroundMusic(currentBgMusic);
                previousAudioState.backgroundMusic = currentBgMusic;
            }

            // Check if sound effects changed
            const currentSoundEffects = displayState.soundEffects || [];
            const prevSoundEffects = previousAudioState.soundEffects || [];
            if (!soundEffectsEqual(currentSoundEffects, prevSoundEffects)) {
                updateSoundEffects(currentSoundEffects);
                previousAudioState.soundEffects = currentSoundEffects;
            }
        }

        function audioStatesEqual(current, previous) {
            if (!current && !previous) return true;
            if (!current || !previous) return false;
            return current.path === previous.path && current.id === previous.id;
        }

        function soundEffectsEqual(current, previous) {
            if (current.length !== previous.length) return false;
            for (let i = 0; i < current.length; i++) {
                if (!audioStatesEqual(current[i], previous[i])) {
                    return false;
                }
            }
            return true;
        }
        
        // Volume control function
        function updateAudioVolume(audioElementId, value) {
            const volume = parseInt(value) / 100;
            const audioElement = document.getElementById(audioElementId);
            
            if (audioElement) {
                audioElement.volume = volume;
                audioElement.dataset.targetVolume = volume; // Update target volume for fading
                
                // Update the volume label
                const slider = event.target;
                const volumeLabel = slider.nextElementSibling;
                if (volumeLabel) {
                    volumeLabel.textContent = value + '%';
                }
            }
        }

        // Store current display state for reference
        let currentDisplayState = { portraits: [], background: null, event: null };

        // Clear specific portrait by index
        async function clearSpecificPortrait(index) {
            try {
                if (currentDisplayState.portraits && currentDisplayState.portraits[index]) {
                    const portraitPath = currentDisplayState.portraits[index].path;
                    await window.electronAPI.clearDisplayElement('portraits', portraitPath);
                }
            } catch (error) {
                console.error('Error clearing specific portrait:', error);
            }
        }

        // Listen for display state updates
        window.electronAPI.onDisplayStateUpdated((event, displayState) => {
            currentDisplayState = displayState; // Store the current state
            updateDisplayPanel(displayState);
            
            // Only update audio if the audio state has actually changed
            updateAudioIfChanged(displayState);
        });

        // Load initial display state
        async function loadDisplayState() {
            try {
                const displayState = await window.electronAPI.getDisplayState();
                currentDisplayState = displayState; // Store the current state
                updateDisplayPanel(displayState);
                
                // Only update audio if the audio state has actually changed
                updateAudioIfChanged(displayState);
            } catch (error) {
                console.error('Error loading display state:', error);
            }
        }

        document.getElementById('refreshBtn2').addEventListener('click', () => {
            loadFileStructure();
        });

        // Party Editor Functionality
        let partyData = [];
        let availablePortraits = [];
        let currentEditingPlayer = null;

        // Collect all available portrait images from the file structure
        function collectPortraits(item, portraits = []) {
            if (item.children && Array.isArray(item.children)) {
                item.children.forEach(child => {
                    if (child.type === 'file' && child.mediaType === 'image' && 
                        (child.mediaSubtype === 'portrait' || child.name.startsWith('_'))) {
                        
                        // Create a clean display name
                        let displayName = child.displayName || child.name;
                        if (displayName === '???') {
                            // For files starting with _, use the filename without extension
                            displayName = child.name.replace(/\.[^/.]+$/, '').substring(1) || 'Unknown';
                        }
                        
                        portraits.push({
                            path: child.path,
                            name: displayName,
                            originalName: child.name,
                            searchTerms: [
                                displayName.toLowerCase(),
                                child.name.toLowerCase(),
                                child.name.replace(/\.[^/.]+$/, '').toLowerCase(), // filename without extension
                                child.name.replace(/^_/, '').replace(/\.[^/.]+$/, '').toLowerCase() // without leading underscore
                            ].join(' ')
                        });
                    } else if (child.type === 'folder') {
                        collectPortraits(child, portraits);
                    }
                });
            }
            return portraits;
        }

        function generatePlayerHTML(player, index) {
            const portraitStyle = player.portrait ? 
                `background-image: url('file://${player.portrait}'); background-size: cover; background-position: center;` : '';
            
            return `
                <div class="player-card" data-index="${index}">
                    <div class="player-portrait ${player.portrait ? 'has-image' : ''}" 
                         style="${portraitStyle}" 
                         onclick="openPortraitModal(${index})">
                        <div class="portrait-icon">👤</div>
                    </div>
                    <div class="player-details">
                        <div class="player-field">
                            <label>Character Name</label>
                            <input type="text" value="${player.name || ''}" 
                                   placeholder="Enter character name" 
                                   onchange="updatePlayer(${index}, 'name', this.value)">
                        </div>
                        <div class="player-stats">
                            <div class="stat-row">
                                <span class="stat-label">AC</span>
                                <input type="number" class="stat-input" value="${player.ac || ''}" 
                                       placeholder="10" min="1" max="30"
                                       onchange="updatePlayer(${index}, 'ac', parseInt(this.value))">
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Passive Perc</span>
                                <input type="number" class="stat-input" value="${player.passivePerception || ''}" 
                                       placeholder="10" min="1" max="30"
                                       onchange="updatePlayer(${index}, 'passivePerception', parseInt(this.value))">
                            </div>
                            <div class="stat-row">
                                <span class="stat-label">Speed</span>
                                <input type="number" class="stat-input" value="${player.speed || ''}" 
                                       placeholder="30" min="0" max="120" step="5"
                                       onchange="updatePlayer(${index}, 'speed', parseInt(this.value))">
                            </div>
                        </div>
                    </div>
                    <div class="player-actions">
                        <button class="remove-player-btn" onclick="removePlayer(${index})">🗑️ Remove</button>
                    </div>
                </div>
            `;
        }

        function renderParty() {
            const partyList = document.getElementById('partyList');
            
            if (partyData.length === 0) {
                partyList.innerHTML = '<div class="empty-state">No players in party. Click "Add Player" to get started!</div>';
                return;
            }
            
            partyList.innerHTML = partyData.map((player, index) => generatePlayerHTML(player, index)).join('');
        }

        function addPlayer() {
            const newPlayer = {
                name: '',
                portrait: null,
                portraitName: '',
                ac: 10,
                passivePerception: 10,
                speed: 30
            };
            partyData.push(newPlayer);
            renderParty();
        }

        function removePlayer(index) {
            if (confirm('Are you sure you want to remove this player?')) {
                partyData.splice(index, 1);
                renderParty();
            }
        }

        function updatePlayer(index, field, value) {
            if (partyData[index]) {
                partyData[index][field] = value;
                console.log('Updated player', index, field, value);
            }
        }

        function openPortraitModal(playerIndex) {
            currentEditingPlayer = playerIndex;
            
            // Update available portraits from current file structure
            if (fileStructure) {
                availablePortraits = collectPortraits(fileStructure);
            }
            
            const portraitGrid = document.getElementById('portraitGrid');
            
            // Add "No Portrait" option
            let portraitOptionsHTML = `
                <div class="portrait-option no-image" onclick="selectPortrait(null, 'No Portrait')" data-name="no portrait none">
                    🚫
                    <div class="portrait-name">No Portrait</div>
                </div>
            `;
            
            // Add available portraits
            portraitOptionsHTML += availablePortraits.map(portrait => `
                <div class="portrait-option" 
                     style="background-image: url('file://${portrait.path}');"
                     onclick="selectPortrait('${portrait.path}', '${portrait.name}')"
                     data-name="${portrait.searchTerms || portrait.name.toLowerCase()}">
                    <div class="portrait-name">${portrait.name}</div>
                </div>
            `).join('');
            
            portraitGrid.innerHTML = portraitOptionsHTML;
            
            // Clear search input
            document.getElementById('portraitSearchInput').value = '';
            
            const modal = document.getElementById('portraitModal');
            modal.classList.add('active');
        }

        function closePortraitModal() {
            const modal = document.getElementById('portraitModal');
            modal.classList.remove('active');
            currentEditingPlayer = null;
            
            // Clear search when closing
            document.getElementById('portraitSearchInput').value = '';
        }
        
        function filterPortraits(searchTerm) {
            const portraits = document.querySelectorAll('.portrait-option');
            const term = searchTerm.toLowerCase().trim();
            const infoEl = document.getElementById('portraitSearchInfo');
            let visibleCount = 0;
            
            portraits.forEach(portrait => {
                const searchableText = portrait.getAttribute('data-name') || '';
                const matches = term === '' || searchableText.includes(term);
                
                if (matches) {
                    portrait.classList.remove('hidden');
                    visibleCount++;
                } else {
                    portrait.classList.add('hidden');
                }
            });
            
            // Update info text
            if (term === '') {
                infoEl.textContent = "Press '/' to focus search • Enter to select first result • Esc to close";
            } else {
                infoEl.textContent = `${visibleCount} portrait${visibleCount !== 1 ? 's' : ''} found • Enter to select first • Esc to close`;
            }
        }

        function selectPortrait(portraitPath, portraitName) {
            if (currentEditingPlayer !== null && partyData[currentEditingPlayer]) {
                partyData[currentEditingPlayer].portrait = portraitPath;
                partyData[currentEditingPlayer].portraitName = portraitName;
                renderParty();
                closePortraitModal();
            }
        }

        async function savePartyData() {
            try {
                if (!currentDirectory) {
                    alert('No directory selected. Please select a directory first.');
                    return;
                }
                
                const partyFilePath = currentDirectory + '/party.json';
                await window.electronAPI.savePartyData(partyFilePath, partyData);
                alert('Party data saved successfully!');
            } catch (error) {
                console.error('Error saving party data:', error);
                alert('Error saving party data: ' + error.message);
            }
        }

        async function loadPartyData() {
            try {
                if (!currentDirectory) {
                    console.log('No directory selected for party data');
                    return;
                }
                
                const partyFilePath = currentDirectory + '/party.json';
                const data = await window.electronAPI.loadPartyData(partyFilePath);
                if (data) {
                    partyData = data;
                    renderParty();
                    console.log('Party data loaded successfully');
                } else {
                    // No party file exists yet, that's okay
                    partyData = [];
                    renderParty();
                }
            } catch (error) {
                console.error('Error loading party data:', error);
                partyData = [];
                renderParty();
            }
        }

        // Event listeners for party editor
        document.getElementById('addPlayerBtn').addEventListener('click', addPlayer);
        document.getElementById('savePartyBtn').addEventListener('click', savePartyData);
        document.getElementById('loadPartyBtn').addEventListener('click', loadPartyData);

        // Encounter Builder Functionality
        let currentEncounter = {
            name: '',
            enemies: []
        };
        let currentEditingEnemy = null;

        function generateEnemyHTML(enemy, index) {
            const portraitStyle = enemy.portrait ? 
                `background-image: url('file://${enemy.portrait}'); background-size: cover; background-position: center;` : '';
            
            return `
                <div class="enemy-card" data-index="${index}">
                    <div class="enemy-portrait ${enemy.portrait ? 'has-image' : ''}" 
                         style="${portraitStyle}" 
                         onclick="openEnemyPortraitModal(${index})">
                        <div class="portrait-icon">👹</div>
                    </div>
                    <div class="enemy-details">
                        <div class="enemy-basic-info">
                            <div class="enemy-field">
                                <label>Enemy Name</label>
                                <input type="text" class="enemy-name-input" value="${enemy.name || ''}" 
                                       placeholder="Enter enemy name" 
                                       onchange="updateEnemy(${index}, 'name', this.value)">
                            </div>
                            <div class="enemy-field">
                                <label>Max HP</label>
                                <input type="number" value="${enemy.maxHp || ''}" 
                                       placeholder="e.g. 45" min="1" max="999"
                                       onchange="updateEnemy(${index}, 'maxHp', parseInt(this.value))">
                            </div>
                            <div class="enemy-field">
                                <label>Speed (ft)</label>
                                <input type="number" value="${enemy.speed || ''}" 
                                       placeholder="e.g. 30" min="0" max="120" step="5"
                                       onchange="updateEnemy(${index}, 'speed', parseInt(this.value))">
                            </div>
                        </div>
                        <div class="enemy-stats">
                            <div class="stat-field">
                                <label>STR</label>
                                <input type="number" value="${enemy.strength || ''}" 
                                       placeholder="10" min="1" max="30"
                                       onchange="updateEnemy(${index}, 'strength', parseInt(this.value))">
                            </div>
                            <div class="stat-field">
                                <label>DEX</label>
                                <input type="number" value="${enemy.dexterity || ''}" 
                                       placeholder="10" min="1" max="30"
                                       onchange="updateEnemy(${index}, 'dexterity', parseInt(this.value))">
                            </div>
                            <div class="stat-field">
                                <label>CON</label>
                                <input type="number" value="${enemy.constitution || ''}" 
                                       placeholder="10" min="1" max="30"
                                       onchange="updateEnemy(${index}, 'constitution', parseInt(this.value))">
                            </div>
                            <div class="stat-field">
                                <label>INT</label>
                                <input type="number" value="${enemy.intelligence || ''}" 
                                       placeholder="10" min="1" max="30"
                                       onchange="updateEnemy(${index}, 'intelligence', parseInt(this.value))">
                            </div>
                            <div class="stat-field">
                                <label>WIS</label>
                                <input type="number" value="${enemy.wisdom || ''}" 
                                       placeholder="10" min="1" max="30"
                                       onchange="updateEnemy(${index}, 'wisdom', parseInt(this.value))">
                            </div>
                            <div class="stat-field">
                                <label>CHA</label>
                                <input type="number" value="${enemy.charisma || ''}" 
                                       placeholder="10" min="1" max="30"
                                       onchange="updateEnemy(${index}, 'charisma', parseInt(this.value))">
                            </div>
                        </div>
                        <div class="enemy-description">
                            <label>Abilities & Notes</label>
                            <textarea placeholder="Enter enemy abilities, attacks, special moves, or tactical notes..."
                                     onchange="updateEnemy(${index}, 'description', this.value)">${enemy.description || ''}</textarea>
                        </div>
                    </div>
                    <div class="enemy-actions">
                        <button class="remove-enemy-btn" onclick="removeEnemy(${index})">🗑️ Remove</button>
                    </div>
                </div>
            `;
        }

        function renderEncounter() {
            const encounterList = document.getElementById('encounterList');
            const encounterNameInput = document.getElementById('encounterNameInput');
            
            if (currentEncounter.enemies.length === 0) {
                encounterList.innerHTML = '<div class="empty-state">No enemies in this encounter. Click "Add Enemy" to get started!</div>';
            } else {
                encounterList.innerHTML = currentEncounter.enemies.map((enemy, index) => generateEnemyHTML(enemy, index)).join('');
            }
            
            encounterNameInput.value = currentEncounter.name;
        }

        function newEncounter() {
            if (currentEncounter.name || currentEncounter.enemies.length > 0) {
                if (!confirm('This will clear the current encounter. Are you sure?')) {
                    return;
                }
            }
            
            currentEncounter = {
                name: '',
                enemies: []
            };
            renderEncounter();
        }

        function addEnemy() {
            const newEnemy = {
                name: '',
                portrait: null,
                portraitName: '',
                maxHp: 1,
                speed: 30,
                strength: 10,
                dexterity: 10,
                constitution: 10,
                intelligence: 10,
                wisdom: 10,
                charisma: 10,
                description: ''
            };
            currentEncounter.enemies.push(newEnemy);
            renderEncounter();
        }

        function removeEnemy(index) {
            if (confirm('Are you sure you want to remove this enemy?')) {
                currentEncounter.enemies.splice(index, 1);
                renderEncounter();
            }
        }

        function updateEnemy(index, field, value) {
            if (currentEncounter.enemies[index]) {
                currentEncounter.enemies[index][field] = value;
                console.log('Updated enemy', index, field, value);
            }
        }

        function updateEncounterName() {
            const encounterNameInput = document.getElementById('encounterNameInput');
            currentEncounter.name = encounterNameInput.value;
        }

        // Enemy portrait selection functions
        function openEnemyPortraitModal(enemyIndex) {
            currentEditingEnemy = enemyIndex;
            
            // Update available portraits from current file structure
            if (fileStructure) {
                availablePortraits = collectPortraits(fileStructure);
            }
            
            const portraitGrid = document.getElementById('enemyPortraitGrid');
            
            // Add "No Portrait" option
            let portraitOptionsHTML = `
                <div class="portrait-option no-image" onclick="selectEnemyPortrait(null, 'No Portrait')" data-name="no portrait none">
                    🚫
                    <div class="portrait-name">No Portrait</div>
                </div>
            `;
            
            // Add available portraits
            portraitOptionsHTML += availablePortraits.map(portrait => `
                <div class="portrait-option" 
                     style="background-image: url('file://${portrait.path}');"
                     onclick="selectEnemyPortrait('${portrait.path}', '${portrait.name}')"
                     data-name="${portrait.searchTerms || portrait.name.toLowerCase()}">
                    <div class="portrait-name">${portrait.name}</div>
                </div>
            `).join('');
            
            portraitGrid.innerHTML = portraitOptionsHTML;
            
            // Clear search input
            document.getElementById('enemyPortraitSearchInput').value = '';
            
            const modal = document.getElementById('enemyPortraitModal');
            modal.classList.add('active');
        }

        function closeEnemyPortraitModal() {
            const modal = document.getElementById('enemyPortraitModal');
            modal.classList.remove('active');
            currentEditingEnemy = null;
            
            // Clear search when closing
            document.getElementById('enemyPortraitSearchInput').value = '';
        }

        function selectEnemyPortrait(portraitPath, portraitName) {
            if (currentEditingEnemy !== null && currentEncounter.enemies[currentEditingEnemy]) {
                currentEncounter.enemies[currentEditingEnemy].portrait = portraitPath;
                currentEncounter.enemies[currentEditingEnemy].portraitName = portraitName;
                renderEncounter();
                closeEnemyPortraitModal();
            }
        }

        function filterEnemyPortraits(searchTerm) {
            const portraits = document.querySelectorAll('#enemyPortraitGrid .portrait-option');
            const term = searchTerm.toLowerCase().trim();
            const infoEl = document.getElementById('enemyPortraitSearchInfo');
            let visibleCount = 0;
            
            portraits.forEach(portrait => {
                const searchableText = portrait.getAttribute('data-name') || '';
                const matches = term === '' || searchableText.includes(term);
                
                if (matches) {
                    portrait.classList.remove('hidden');
                    visibleCount++;
                } else {
                    portrait.classList.add('hidden');
                }
            });
            
            // Update info text
            if (term === '') {
                infoEl.textContent = "Press '/' to focus search • Enter to select first result • Esc to close";
            } else {
                infoEl.textContent = `${visibleCount} portrait${visibleCount !== 1 ? 's' : ''} found • Enter to select first • Esc to close`;
            }
        }

        async function saveEncounterData() {
            try {
                if (!currentDirectory) {
                    alert('No directory selected. Please select a directory first.');
                    return;
                }
                
                if (!currentEncounter.name) {
                    alert('Please enter an encounter name before saving.');
                    return;
                }
                
                const encounterFilePath = currentDirectory + '/' + currentEncounter.name + '_encounter.json';
                await window.electronAPI.saveEncounterData(encounterFilePath, currentEncounter);
                alert('Encounter saved successfully!');
            } catch (error) {
                console.error('Error saving encounter data:', error);
                alert('Error saving encounter data: ' + error.message);
            }
        }

        async function loadEncounterData() {
            try {
                if (!currentDirectory) {
                    alert('No directory selected. Please select a directory first.');
                    return;
                }
                
                // Get list of encounter files
                const encounterFiles = await window.electronAPI.getEncounterFiles(currentDirectory);
                
                if (encounterFiles.length === 0) {
                    alert('No encounter files found in the current directory.');
                    return;
                }
                
                // Show encounter selection modal
                showEncounterSelectionModal(encounterFiles);
                
            } catch (error) {
                console.error('Error loading encounter files:', error);
                alert('Error loading encounter files: ' + error.message);
            }
        }

        function showEncounterSelectionModal(encounterFiles) {
            const modal = document.getElementById('encounterSelectionModal');
            const container = document.getElementById('encounterListContainer');
            
            if (encounterFiles.length === 0) {
                container.innerHTML = '<div class="no-encounters">No encounter files found in this directory.</div>';
            } else {
                container.innerHTML = encounterFiles.map(encounter => {
                    const date = new Date(encounter.lastModified).toLocaleDateString();
                    const time = new Date(encounter.lastModified).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    
                    return `
                        <div class="encounter-item" onclick="selectEncounterFile('${encounter.path}', '${encounter.name}')">
                            <div class="encounter-item-info">
                                <div class="encounter-item-name">${encounter.name}</div>
                                <div class="encounter-item-details">
                                    <span>📁 ${encounter.filename}</span>
                                </div>
                            </div>
                            <div class="encounter-item-meta">
                                <div class="encounter-enemy-count">${encounter.enemyCount} ${encounter.enemyCount === 1 ? 'enemy' : 'enemies'}</div>
                                <div class="encounter-item-date">${date} ${time}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            modal.classList.add('active');
        }

        function closeEncounterSelectionModal() {
            const modal = document.getElementById('encounterSelectionModal');
            modal.classList.remove('active');
        }

        async function selectEncounterFile(filePath, encounterName) {
            try {
                const data = await window.electronAPI.loadEncounterData(filePath);
                if (data) {
                    currentEncounter = data;
                    renderEncounter();
                    closeEncounterSelectionModal();
                    console.log('Encounter loaded successfully:', encounterName);
                }
            } catch (error) {
                console.error('Error loading encounter:', error);
                alert('Error loading encounter: ' + error.message);
            }
        }

        // Event listeners for encounter builder
        document.getElementById('newEncounterBtn').addEventListener('click', newEncounter);
        document.getElementById('addEnemyBtn').addEventListener('click', addEnemy);
        document.getElementById('saveEncounterBtn').addEventListener('click', saveEncounterData);
        document.getElementById('loadEncounterBtn').addEventListener('click', loadEncounterData);
        document.getElementById('encounterNameInput').addEventListener('input', updateEncounterName);

        // Initiative Tracker Functionality
        let initiativeOrder = [];
        let currentTurnIndex = 0;
        let currentRound = 1;

        // Calculate D&D initiative modifier from dexterity score
        function getInitiativeModifier(dexScore) {
            return Math.floor((dexScore - 10) / 2);
        }

        // Roll initiative (1d20 + modifier)
        function rollInitiative(modifier = 0) {
            return Math.floor(Math.random() * 20) + 1 + modifier;
        }

        function generateInitiativeItemHTML(item, index) {
            const portraitStyle = item.portrait ? 
                `background-image: url('file://${item.portrait}'); background-size: cover; background-position: center;` : '';
            
            const isCurrentTurn = index === currentTurnIndex;
            const typeClass = item.type === 'player' ? 'player' : (item.type === 'enemy' ? 'enemy' : 'note');
            
            // HP tracking for enemies
            let hpSection = '';
            if (item.type === 'enemy' && item.maxHP !== undefined) {
                const currentHP = item.currentHP !== undefined ? item.currentHP : item.maxHP;
                const hpPercentage = (currentHP / item.maxHP) * 100;
                let hpClass = '';
                if (hpPercentage <= 25) hpClass = 'low-hp';
                else if (hpPercentage <= 50) hpClass = 'half-hp';
                
                hpSection = `
                    <div class="hp-controls">
                        <div class="hp-display ${hpClass}" onclick="openHPModal(${index})" title="Click to adjust HP">
                            ${currentHP}/${item.maxHP} HP
                        </div>
                        <button class="info-btn" onclick="openEnemyInfoModal(${index})" title="View enemy details">ℹ️</button>
                    </div>
                `;
            }
            
            return `
                <div class="initiative-item ${typeClass} ${isCurrentTurn ? 'current-turn' : ''}" data-index="${index}">
                    ${isCurrentTurn ? '<div class="current-turn-indicator">▶</div>' : ''}
                    <div class="initiative-portrait ${item.portrait ? 'has-image' : ''}" 
                         style="${portraitStyle}" 
                         onclick="${item.type === 'enemy' ? `openEnemyInfoModal(${index})` : ''}"
                         title="${item.type === 'enemy' ? 'Click to view enemy details' : ''}">
                        <div class="initiative-icon">${item.icon || '👤'}</div>
                    </div>
                    <div class="initiative-info">
                        <div class="initiative-name">${item.name}</div>
                        <div class="initiative-type">${item.type}${item.description ? ' - ' + item.description : ''}</div>
                        ${hpSection}
                    </div>
                    <div class="initiative-order">
                        <input type="number" class="initiative-input" value="${item.initiative}" 
                               onchange="updateInitiativeValue(${index}, parseInt(this.value))" 
                               min="0" max="50">
                    </div>
                    <div class="initiative-actions-cell">
                        <button class="remove-initiative-btn" onclick="removeInitiativeItem(${index})">Remove</button>
                    </div>
                </div>
            `;
        }

        function renderInitiativeOrder() {
            const initiativeList = document.getElementById('initiativeList');
            
            if (initiativeOrder.length === 0) {
                initiativeList.innerHTML = '<div class="empty-state">No combatants in initiative. Add party members or encounters to get started!</div>';
                return;
            }
            
            // Sort by initiative (highest first)
            const sortedOrder = [...initiativeOrder].sort((a, b) => b.initiative - a.initiative);
            
            // Find current turn index in sorted order
            if (initiativeOrder.length > 0 && currentTurnIndex < initiativeOrder.length) {
                const currentItem = initiativeOrder[currentTurnIndex];
                currentTurnIndex = sortedOrder.findIndex(item => item.id === currentItem.id);
            }
            
            // Update the main array to match sorted order
            initiativeOrder = sortedOrder;
            
            initiativeList.innerHTML = sortedOrder.map((item, index) => generateInitiativeItemHTML(item, index)).join('');
            
            // Update round counter display
            document.getElementById('roundCounter').textContent = currentRound;
        }

        function addPartyToInitiative() {
            if (!partyData || partyData.length === 0) {
                alert('No party data found. Please create a party first.');
                return;
            }
            
            partyData.forEach(player => {
                const playerId = Date.now() + Math.random();
                initiativeOrder.push({
                    id: playerId,
                    name: player.name || 'Unnamed Player',
                    type: 'player',
                    portrait: player.portrait,
                    icon: '👤',
                    initiative: 0, // Players start with blank initiative
                    source: 'party'
                });
            });
            
            renderInitiativeOrder();
        }

        async function addEncounterToInitiative() {
            try {
                if (!currentDirectory) {
                    alert('No directory selected. Please select a directory first.');
                    return;
                }
                
                // Get list of encounter files
                const encounterFiles = await window.electronAPI.getEncounterFiles(currentDirectory);
                
                if (encounterFiles.length === 0) {
                    alert('No encounter files found in the current directory.');
                    return;
                }
                
                // Show encounter selection for initiative
                showEncounterSelectionForInitiative(encounterFiles);
                
            } catch (error) {
                console.error('Error loading encounter files for initiative:', error);
                alert('Error loading encounter files: ' + error.message);
            }
        }

        function showEncounterSelectionForInitiative(encounterFiles) {
            const modal = document.getElementById('encounterSelectionModal');
            const container = document.getElementById('encounterListContainer');
            
            // Update modal title for initiative context
            modal.querySelector('.encounter-modal-title').textContent = 'Add Encounter to Initiative';
            
            if (encounterFiles.length === 0) {
                container.innerHTML = '<div class="no-encounters">No encounter files found in this directory.</div>';
            } else {
                container.innerHTML = encounterFiles.map(encounter => {
                    const date = new Date(encounter.lastModified).toLocaleDateString();
                    const time = new Date(encounter.lastModified).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    
                    return `
                        <div class="encounter-item" onclick="addEncounterToInitiativeOrder('${encounter.path}', '${encounter.name}')">
                            <div class="encounter-item-info">
                                <div class="encounter-item-name">${encounter.name}</div>
                                <div class="encounter-item-details">
                                    <span>📁 ${encounter.filename}</span>
                                </div>
                            </div>
                            <div class="encounter-item-meta">
                                <div class="encounter-enemy-count">${encounter.enemyCount} ${encounter.enemyCount === 1 ? 'enemy' : 'enemies'}</div>
                                <div class="encounter-item-date">${date} ${time}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            modal.classList.add('active');
        }

        async function addEncounterToInitiativeOrder(filePath, encounterName) {
            try {
                const encounter = await window.electronAPI.loadEncounterData(filePath);
                if (encounter && encounter.enemies) {
                    encounter.enemies.forEach(enemy => {
                        const enemyId = Date.now() + Math.random();
                        const dexModifier = getInitiativeModifier(enemy.dexterity || 10);
                        const rolledInitiative = rollInitiative(dexModifier);
                        
                        initiativeOrder.push({
                            id: enemyId,
                            name: enemy.name || 'Unnamed Enemy',
                            type: 'enemy',
                            portrait: enemy.portrait,
                            icon: '👹',
                            initiative: rolledInitiative,
                            maxHP: enemy.maxHp || 1,
                            currentHP: enemy.maxHp || 1,
                            speed: enemy.speed,
                            strength: enemy.strength,
                            dexterity: enemy.dexterity,
                            constitution: enemy.constitution,
                            intelligence: enemy.intelligence,
                            wisdom: enemy.wisdom,
                            charisma: enemy.charisma,
                            description: enemy.description,
                            source: 'encounter',
                            encounterName: encounterName
                        });
                    });
                    
                    closeEncounterSelectionModal();
                    renderInitiativeOrder();
                    console.log(`Added ${encounter.enemies.length} enemies from ${encounterName} to initiative`);
                }
            } catch (error) {
                console.error('Error adding encounter to initiative:', error);
                alert('Error adding encounter to initiative: ' + error.message);
            }
        }

        function updateInitiativeValue(index, newValue) {
            if (initiativeOrder[index] && !isNaN(newValue)) {
                initiativeOrder[index].initiative = newValue;
                // Re-render to re-sort the order
                setTimeout(() => renderInitiativeOrder(), 100);
            }
        }

        function removeInitiativeItem(index) {
            if (confirm('Remove this combatant from initiative?')) {
                // Adjust current turn index if necessary
                if (index < currentTurnIndex) {
                    currentTurnIndex--;
                } else if (index === currentTurnIndex && currentTurnIndex >= initiativeOrder.length - 1) {
                    currentTurnIndex = 0;
                }
                
                initiativeOrder.splice(index, 1);
                
                // Ensure currentTurnIndex is valid
                if (initiativeOrder.length === 0) {
                    currentTurnIndex = 0;
                } else if (currentTurnIndex >= initiativeOrder.length) {
                    currentTurnIndex = 0;
                }
                
                renderInitiativeOrder();
            }
        }

        function nextTurn() {
            if (initiativeOrder.length === 0) return;
            
            currentTurnIndex++;
            if (currentTurnIndex >= initiativeOrder.length) {
                currentTurnIndex = 0;
                currentRound++;
            }
            
            renderInitiativeOrder();
            saveInitiativeState();
        }

        function previousTurn() {
            if (initiativeOrder.length === 0) return;
            
            currentTurnIndex--;
            if (currentTurnIndex < 0) {
                currentTurnIndex = initiativeOrder.length - 1;
                currentRound = Math.max(1, currentRound - 1);
            }
            
            renderInitiativeOrder();
            saveInitiativeState();
        }

        function clearInitiative() {
            if (initiativeOrder.length === 0) return;
            
            if (confirm('Clear all combatants from initiative? This cannot be undone.')) {
                initiativeOrder = [];
                currentTurnIndex = 0;
                currentRound = 1;
                renderInitiativeOrder();
                saveInitiativeState();
            }
        }

        // Initiative state management
        async function saveInitiativeState() {
            if (!currentDirectory) return;
            
            const initiativeData = {
                order: initiativeOrder,
                currentTurnIndex: currentTurnIndex,
                currentRound: currentRound,
                timestamp: Date.now()
            };
            
            try {
                await window.electronAPI.saveInitiativeData(currentDirectory, initiativeData);
                console.log('Initiative state saved');
            } catch (error) {
                console.error('Error saving initiative state:', error);
            }
        }

        async function loadInitiativeState() {
            if (!currentDirectory) return;
            
            try {
                const initiativeData = await window.electronAPI.loadInitiativeData(currentDirectory);
                if (initiativeData) {
                    initiativeOrder = initiativeData.order || [];
                    currentTurnIndex = initiativeData.currentTurnIndex || 0;
                    currentRound = initiativeData.currentRound || 1;
                    
                    // Ensure currentTurnIndex is valid
                    if (currentTurnIndex >= initiativeOrder.length) {
                        currentTurnIndex = 0;
                    }
                    
                    renderInitiativeOrder();
                    console.log('Initiative state loaded');
                }
            } catch (error) {
                console.error('Error loading initiative state:', error);
            }
        }

        // Note functionality
        function openNoteModal() {
            const modal = document.getElementById('noteModal');
            
            // Clear previous values
            document.getElementById('noteInitiative').value = '';
            document.getElementById('noteTitle').value = '';
            document.getElementById('noteDescription').value = '';
            
            modal.classList.add('active');
        }

        function closeNoteModal() {
            const modal = document.getElementById('noteModal');
            modal.classList.remove('active');
        }

        function addInitiativeNote(event) {
            event.preventDefault();
            
            const initiative = parseInt(document.getElementById('noteInitiative').value);
            const title = document.getElementById('noteTitle').value.trim();
            const description = document.getElementById('noteDescription').value.trim();
            
            if (!title || isNaN(initiative)) {
                alert('Please enter both initiative value and note title.');
                return;
            }
            
            const noteId = Date.now() + Math.random();
            initiativeOrder.push({
                id: noteId,
                name: title,
                type: 'note',
                description: description || '',
                icon: '📝',
                initiative: initiative,
                source: 'note'
            });
            
            closeNoteModal();
            renderInitiativeOrder();
        }

        // HP Modal functionality
        let currentHPIndex = -1;

        function openHPModal(index) {
            if (!initiativeOrder[index] || initiativeOrder[index].type !== 'enemy') return;
            
            currentHPIndex = index;
            const enemy = initiativeOrder[index];
            
            document.getElementById('hpModalTitle').textContent = `Adjust HP - ${enemy.name}`;
            document.getElementById('currentHPDisplay').textContent = 
                `Current HP: ${enemy.currentHP}/${enemy.maxHP}`;
            document.getElementById('hpAmount').value = '';
            
            const modal = document.getElementById('hpModal');
            modal.classList.add('active');
            
            // Focus on the input field
            setTimeout(() => {
                const input = document.getElementById('hpAmount');
                input.focus();
                
                // Add keyboard shortcuts
                input.onkeydown = function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (e.shiftKey) {
                            applyHPChange('heal');
                        } else {
                            applyHPChange('damage');
                        }
                    }
                };
            }, 100);
        }

        function closeHPModal() {
            const modal = document.getElementById('hpModal');
            modal.classList.remove('active');
            currentHPIndex = -1;
        }

        function applyHPChange(type) {
            if (currentHPIndex === -1 || !initiativeOrder[currentHPIndex]) return;
            
            const amount = parseInt(document.getElementById('hpAmount').value);
            if (isNaN(amount) || amount <= 0) {
                alert('Please enter a valid positive number.');
                return;
            }
            
            const changeAmount = type === 'damage' ? -amount : amount;
            adjustHP(currentHPIndex, changeAmount);
            closeHPModal();
        }

        // Update the adjustHP function to handle the modal case
        function adjustHP(index, amount) {
            if (!initiativeOrder[index] || initiativeOrder[index].type !== 'enemy') return;
            
            const enemy = initiativeOrder[index];
            enemy.currentHP = Math.max(0, Math.min(enemy.maxHP, enemy.currentHP + amount));
            
            renderInitiativeOrder();
            saveInitiativeState();
        }

        // Enemy Info Modal functionality
        function getStatModifier(score) {
            return Math.floor((score - 10) / 2);
        }

        function formatModifier(modifier) {
            return modifier >= 0 ? `+${modifier}` : `${modifier}`;
        }

        function openEnemyInfoModal(index) {
            if (!initiativeOrder[index] || initiativeOrder[index].type !== 'enemy') return;
            
            const enemy = initiativeOrder[index];
            
            // Set title
            document.getElementById('enemyInfoTitle').textContent = `${enemy.name} - Character Sheet`;
            
            // Generate content with horizontal layout
            const content = document.getElementById('enemyInfoContent');
            
            // Calculate HP percentage for color coding
            const hpPercentage = (enemy.currentHP / enemy.maxHP) * 100;
            let hpClass = '';
            if (hpPercentage <= 25) hpClass = 'low-hp';
            else if (hpPercentage <= 50) hpClass = 'half-hp';
            
            // Portrait styling
            const portraitStyle = enemy.portrait ? 
                `background-image: url('file://${enemy.portrait}'); background-size: cover; background-position: center;` : '';
            
            content.innerHTML = `
                <div class="enemy-info-content">
                    <div class="enemy-info-left">
                        <div class="enemy-portrait-section">
                            <div class="enemy-portrait-large" style="${portraitStyle}">
                                ${enemy.portrait ? '' : '👹'}
                            </div>
                            <h2 class="enemy-name-large">${enemy.name}</h2>
                            <div class="enemy-type-info">Initiative: ${enemy.initiative}</div>
                        </div>
                        
                        <div class="enemy-vital-stats">
                            <div class="vital-stat-row">
                                <span class="vital-stat-label">Hit Points</span>
                                <span class="vital-stat-value hp-display ${hpClass}">${enemy.currentHP}/${enemy.maxHP}</span>
                            </div>
                            <div class="vital-stat-row">
                                <span class="vital-stat-label">Speed</span>
                                <span class="vital-stat-value">${enemy.speed || 30} ft</span>
                            </div>
                        </div>
                        
                        <div class="enemy-stats-section">
                            <h4 style="color: #e74c3c; text-align: center; margin-bottom: 15px;">ABILITY SCORES</h4>
                            <div class="enemy-stats-grid">
                                <div class="stat-item">
                                    <div class="stat-name">STR</div>
                                    <div class="stat-value">${enemy.strength || 10}</div>
                                    <div class="stat-modifier">(${formatModifier(getStatModifier(enemy.strength || 10))})</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-name">DEX</div>
                                    <div class="stat-value">${enemy.dexterity || 10}</div>
                                    <div class="stat-modifier">(${formatModifier(getStatModifier(enemy.dexterity || 10))})</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-name">CON</div>
                                    <div class="stat-value">${enemy.constitution || 10}</div>
                                    <div class="stat-modifier">(${formatModifier(getStatModifier(enemy.constitution || 10))})</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-name">INT</div>
                                    <div class="stat-value">${enemy.intelligence || 10}</div>
                                    <div class="stat-modifier">(${formatModifier(getStatModifier(enemy.intelligence || 10))})</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-name">WIS</div>
                                    <div class="stat-value">${enemy.wisdom || 10}</div>
                                    <div class="stat-modifier">(${formatModifier(getStatModifier(enemy.wisdom || 10))})</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-name">CHA</div>
                                    <div class="stat-value">${enemy.charisma || 10}</div>
                                    <div class="stat-modifier">(${formatModifier(getStatModifier(enemy.charisma || 10))})</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="enemy-info-right">
                        <div class="enemy-description-section">
                            <h4>Abilities & Actions</h4>
                            ${enemy.description && enemy.description.trim() ? 
                                `<div class="enemy-description-text">${enemy.description}</div>` : 
                                `<div class="empty-description">No abilities or notes recorded for this enemy.</div>`
                            }
                        </div>
                    </div>
                </div>
            `;
            
            const modal = document.getElementById('enemyInfoModal');
            modal.classList.add('active');
        }

        function closeEnemyInfoModal() {
            const modal = document.getElementById('enemyInfoModal');
            modal.classList.remove('active');
        }

        // Event listeners for initiative tracker
        document.getElementById('addPartyBtn').addEventListener('click', addPartyToInitiative);
        document.getElementById('addEncounterToInitiativeBtn').addEventListener('click', addEncounterToInitiative);
        document.getElementById('addNoteBtn').addEventListener('click', openNoteModal);
        document.getElementById('clearInitiativeBtn').addEventListener('click', clearInitiative);
        document.getElementById('nextTurnBtn').addEventListener('click', nextTurn);
        document.getElementById('prevTurnBtn').addEventListener('click', previousTurn);

        // Battlemap Functionality
        let battlemapData = {
            backgroundImage: null,
            gridWidth: 20,
            gridHeight: 15,
            imageAspectRatio: null,
            tokens: {}, // key: "x-y", value: {name, portrait, type}
            moveMode: {
                active: false,
                selectedToken: null,
                originalPosition: null
            },
            displayActive: false,
            displayZoom: {
                scale: 1.0,
                centerX: 0.5, // 0.5 = center of grid
                centerY: 0.5,
                lastMovedToken: null
            }
        };

        function generateBattlemapGrid() {
            const container = document.getElementById('battlemapContainer');
            const { gridWidth, gridHeight } = battlemapData;
            
            console.log('Generating battlemap grid:', gridWidth, 'x', gridHeight);
            console.log('Background image:', battlemapData.backgroundImage);
            console.log('File structure available:', !!fileStructure);
            
            const grid = document.createElement('div');
            grid.className = 'battlemap-grid';
            grid.style.gridTemplateColumns = `repeat(${gridWidth}, 1fr)`;
            
            // Set background image if available
            if (battlemapData.backgroundImage) {
                grid.style.backgroundImage = `url('file://${battlemapData.backgroundImage}')`;
            }
            
            // Create cells
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'battlemap-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    // Check if this position has a token
                    const tokenKey = `${x}-${y}`;
                    const token = battlemapData.tokens[tokenKey];
                    
                    if (token) {
                        cell.classList.add('occupied');
                        const tokenElement = document.createElement('div');
                        tokenElement.className = 'battlemap-token';
                        
                        // Apply transparency for hidden tokens
                        if (token.hidden) {
                            tokenElement.style.opacity = '0.3';
                            tokenElement.classList.add('hidden-token');
                        }
                        
                        if (token.portrait) {
                            tokenElement.style.backgroundImage = `url('file://${token.portrait}')`;
                        } else {
                            tokenElement.className += ' no-image';
                            tokenElement.textContent = token.name.charAt(0).toUpperCase();
                        }
                        
                        const nameElement = document.createElement('div');
                        nameElement.className = 'token-name';
                        nameElement.textContent = token.name;
                        tokenElement.appendChild(nameElement);
                        
                        // Prevent default right-click context menu and handle our custom one
                        tokenElement.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            showBattlemapContextMenu(e, x, y, token);
                        });
                        
                        // Left-click also shows context menu (replaces move mode behavior)
                        tokenElement.addEventListener('click', (e) => {
                            e.stopPropagation();
                            showBattlemapContextMenu(e, x, y, token);
                        });
                        
                        // Apply move mode styling if this token is selected
                        if (battlemapData.moveMode.active && 
                            battlemapData.moveMode.originalPosition === `${x}-${y}`) {
                            tokenElement.classList.add('selected-for-move');
                        }
                        
                        cell.appendChild(tokenElement);
                    }
                    
                    // Right-click context menu for cells
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showBattlemapContextMenu(e, x, y, token);
                    });
                    
                    // Left-click also shows context menu (replaces add token/move token behavior)
                    cell.addEventListener('click', (e) => {
                        // Only show context menu if not in move mode
                        if (battlemapData.moveMode.active) {
                            // In move mode - move the selected token to this position
                            moveTokenToPosition(x, y);
                        } else {
                            // Show context menu instead of directly opening token modal
                            showBattlemapContextMenu(e, x, y, token);
                        }
                    });
                    
                    // Apply move mode styling for valid move targets
                    if (battlemapData.moveMode.active && !token) {
                        cell.classList.add('move-target');
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            container.innerHTML = '';
            
            // If no background is set, show empty state
            if (!battlemapData.backgroundImage) {
                container.innerHTML = '<div class="empty-state">Select a location background to start building your battlemap!</div>';
                return;
            }
            
            // Add move mode overlay if active
            if (battlemapData.moveMode.active) {
                const overlay = document.createElement('div');
                overlay.className = 'move-mode-overlay';
                overlay.innerHTML = `🏃‍♂️ Move Mode: Click to move "${battlemapData.moveMode.selectedToken.name}" or press ESC to cancel`;
                container.appendChild(overlay);
            }
            
            container.appendChild(grid);
        }

        function updateBattlemapGrid() {
            // Always use width-based mode with auto-calculated height
            if (battlemapData.imageAspectRatio) {
                // Image-based mode - calculate height from width and aspect ratio
                updateGridDimensionsFromImage();
            } else {
                // No image yet - use manual width value
                const width = parseInt(document.getElementById('gridWidth').value);
                
                if (width >= 5 && width <= 50) {
                    // Remove tokens that are outside new grid bounds
                    const newTokens = {};
                    Object.entries(battlemapData.tokens).forEach(([key, token]) => {
                        const [x, y] = key.split('-').map(Number);
                        if (x < width && y < battlemapData.gridHeight) {
                            newTokens[key] = token;
                        }
                    });
                    
                    battlemapData.gridWidth = width;
                    battlemapData.tokens = newTokens;
                    
                    generateBattlemapGrid();
                    saveBattlemapData();
                }
            }
        }

        function selectBattlemapBackground() {
            console.log('selectBattlemapBackground called!'); // Debug log
            
            if (!fileStructure) {
                console.log('No file structure available'); // Debug log
                alert('File structure not loaded. Please wait and try again.');
                return;
            }
            
            // Open the background selection modal
            openBattlemapBackgroundModal();
        }

        function openBattlemapBackgroundModal() {
            // Use the same pattern as Media panel for collecting backgrounds
            const locationImages = collectBackgrounds(fileStructure);
            
            console.log('Found location images:', locationImages); // Debug log
            
            if (locationImages.length === 0) {
                alert('No location images found! Location images should end with "_location"');
                return;
            }
            
            // Populate the background grid
            populateBattlemapBackgroundGrid(locationImages);
            
            // Show the modal
            const modal = document.getElementById('battlemapBackgroundModal');
            modal.style.display = 'flex';
            
            // Clear and focus search
            const searchInput = document.getElementById('battlemapBackgroundSearchInput');
            searchInput.value = '';
            setTimeout(() => searchInput.focus(), 100);
        }

        function populateBattlemapBackgroundGrid(backgrounds = null) {
            const grid = document.getElementById('battlemapBackgroundGrid');
            
            if (!backgrounds) {
                backgrounds = collectBackgrounds(fileStructure);
            }
            
            if (backgrounds.length === 0) {
                grid.innerHTML = '<div class="empty-state">No location images found. Make sure you have images ending with "_location"!</div>';
                return;
            }
            
            grid.innerHTML = backgrounds.map(background => {
                return `
                    <div class="portrait-option" 
                         style="background-image: url('file://${background.path}');"
                         onclick="selectBattlemapBackgroundImage('${background.path}', '${background.name}')"
                         data-name="${background.name.toLowerCase()}">
                        <div class="portrait-name">${background.name}</div>
                    </div>
                `;
            }).join('');
        }

        function selectBattlemapBackgroundImage(imagePath, imageName) {
            battlemapData.backgroundImage = imagePath;
            
            // Calculate image dimensions and update grid if in image-based mode
            calculateImageDimensions(imagePath);
            
            generateBattlemapGrid();
            saveBattlemapData();
            closeBattlemapBackgroundModal();
            console.log('Battlemap background set to:', imageName);
        }

        function calculateImageDimensions(imagePath) {
            const img = new Image();
            img.onload = function() {
                const aspectRatio = this.naturalWidth / this.naturalHeight;
                battlemapData.imageAspectRatio = aspectRatio;
                
                console.log(`Image dimensions: ${this.naturalWidth}x${this.naturalHeight}, aspect ratio: ${aspectRatio.toFixed(2)}`);
                
                // Update aspect ratio display
                document.getElementById('imageRatio').textContent = `${this.naturalWidth}×${this.naturalHeight} (${aspectRatio.toFixed(2)}:1)`;
                
                // Always recalculate grid dimensions based on width and image aspect ratio
                updateGridDimensionsFromImage();
            };
            img.src = `file://${imagePath}`;
        }

        function updateGridDimensionsFromImage() {
            const aspectRatio = battlemapData.imageAspectRatio;
            
            if (!aspectRatio) {
                document.getElementById('aspectRatioInfo').style.display = 'none';
                document.getElementById('imageRatio').textContent = 'Select background first';
                return;
            }
            
            // Always use width-based mode - user sets width, calculate height from aspect ratio
            const width = parseInt(document.getElementById('gridWidth').value);
            const calculatedHeight = Math.max(5, Math.min(50, Math.round(width / aspectRatio)));
            
            battlemapData.gridHeight = calculatedHeight;
            document.getElementById('gridHeight').value = calculatedHeight;
            
            // Update the data and regenerate grid
            battlemapData.gridWidth = parseInt(document.getElementById('gridWidth').value);
            battlemapData.gridHeight = calculatedHeight;
            generateBattlemapGrid();
        }

        function closeBattlemapBackgroundModal() {
            const modal = document.getElementById('battlemapBackgroundModal');
            modal.style.display = 'none';
            document.getElementById('battlemapBackgroundSearchInput').value = '';
        }

        function filterBattlemapBackgrounds(searchTerm) {
            const options = document.querySelectorAll('#battlemapBackgroundGrid .portrait-option');
            const term = searchTerm.toLowerCase();
            
            options.forEach(option => {
                const name = option.getAttribute('data-name');
                if (name.includes(term)) {
                    option.style.display = 'block';
                } else {
                    option.style.display = 'none';
                }
            });
        }

        function collectBackgrounds(item, backgrounds = []) {
            if (item.children && Array.isArray(item.children)) {
                item.children.forEach(child => {
                    if (child.type === 'file' && child.mediaType === 'image' && 
                        (child.mediaSubtype === 'background' || child.name.includes('_location'))) {
                        backgrounds.push({
                            path: child.path,
                            name: child.displayName || child.name,
                            originalName: child.name
                        });
                    } else if (child.type === 'folder') {
                        collectBackgrounds(child, backgrounds);
                    }
                });
            }
            return backgrounds;
        }

        function clearBattlemap() {
            if (Object.keys(battlemapData.tokens).length > 0 || battlemapData.backgroundImage) {
                if (confirm('Clear all tokens and background from the battlemap?')) {
                    battlemapData.tokens = {};
                    battlemapData.backgroundImage = null;
                    generateBattlemapGrid();
                    saveBattlemapData();
                }
            }
        }

        // Token Move Mode Functions
        function enterTokenMoveMode(x, y, token) {
            battlemapData.moveMode.active = true;
            battlemapData.moveMode.originalPosition = `${x}-${y}`;
            battlemapData.moveMode.selectedToken = token;
            
            console.log(`Entering move mode for ${token.name} at ${x},${y}`);
            
            // Regenerate grid to show move mode styling
            generateBattlemapGrid();
        }

        function moveTokenToPosition(newX, newY) {
            const { originalPosition, selectedToken } = battlemapData.moveMode;
            const newPosition = `${newX}-${newY}`;
            
            // Check if target position is empty
            if (battlemapData.tokens[newPosition]) {
                alert('Cannot move token to occupied position!');
                return;
            }
            
            // Move the token
            delete battlemapData.tokens[originalPosition];
            battlemapData.tokens[newPosition] = selectedToken;
            
            // Track the moved token for zoom focus
            battlemapData.displayZoom.lastMovedToken = {
                x: newX,
                y: newY,
                name: selectedToken.name
            };
            
            // Auto-zoom to moved token on display if active and token is visible
            if (battlemapData.displayActive && !selectedToken.hidden) {
                zoomToToken(newX, newY);
            }
            
            console.log(`Moved ${selectedToken.name} from ${originalPosition} to ${newPosition}`);
            
            // Exit move mode
            exitTokenMoveMode();
            
            // Save and regenerate
            saveBattlemapData();
            generateBattlemapGrid();
            
            // Update display if active
            if (battlemapData.displayActive) {
                showBattlemapOnDisplay();
            }
        }

        // Zoom Control Functions
        function zoomIn() {
            const previousScale = battlemapData.displayZoom.scale;
            battlemapData.displayZoom.scale = Math.min(battlemapData.displayZoom.scale * 1.2, 4.0); // Reduced from 1.5 to 1.2
            
            // Maintain center point when zooming
            maintainZoomCenter(previousScale, battlemapData.displayZoom.scale);
            
            if (battlemapData.displayActive) {
                showBattlemapOnDisplay();
            }
        }

        function zoomOut() {
            const previousScale = battlemapData.displayZoom.scale;
            battlemapData.displayZoom.scale = Math.max(battlemapData.displayZoom.scale / 1.2, 0.3); // Reduced from 1.5 to 1.2
            
            // Maintain center point when zooming
            maintainZoomCenter(previousScale, battlemapData.displayZoom.scale);
            
            if (battlemapData.displayActive) {
                showBattlemapOnDisplay();
            }
        }

        function resetZoom() {
            battlemapData.displayZoom.scale = 1.0;
            battlemapData.displayZoom.centerX = 0.5;
            battlemapData.displayZoom.centerY = 0.5;
            battlemapData.displayZoom.lastMovedToken = null;
            
            if (battlemapData.displayActive) {
                showBattlemapOnDisplay();
            }
        }

        function maintainZoomCenter(oldScale, newScale) {
            // This function ensures that when zooming, the current center point 
            // remains at the center of the viewport
            // For now, we keep the center the same, but this could be enhanced
            // to account for mouse position or other factors
        }

        function zoomToToken(x, y) {
            // Calculate center position (0 to 1) based on token position
            // Add 0.5 to center on the token rather than its corner
            battlemapData.displayZoom.centerX = (x + 0.5) / battlemapData.gridWidth;
            battlemapData.displayZoom.centerY = (y + 0.5) / battlemapData.gridHeight;
            
            // Don't change zoom level - preserve current zoom
            // battlemapData.displayZoom.scale = Math.min(2.5, battlemapData.displayZoom.scale * 1.2);
            
            console.log(`Zooming to token at ${x},${y} - Center: ${battlemapData.displayZoom.centerX.toFixed(2)}, ${battlemapData.displayZoom.centerY.toFixed(2)}, Scale: ${battlemapData.displayZoom.scale.toFixed(2)}`);
        }

        function focusOnCharacter(characterName) {
            // Find the character's position on the battlemap
            for (const [key, token] of Object.entries(battlemapData.tokens)) {
                if (token.name.toLowerCase().includes(characterName.toLowerCase())) {
                    const [x, y] = key.split('-').map(Number);
                    zoomToToken(x, y);
                    
                    // Mark this as the last moved token for highlighting
                    battlemapData.displayZoom.lastMovedToken = { x, y, name: token.name };
                    
                    if (battlemapData.displayActive) {
                        showBattlemapOnDisplay();
                    }
                    return true;
                }
            }
            return false;
        }

        // Add mouse wheel zoom support (you can expand this later)
        function setupBattlemapZoomControls() {
            // This would be called after the battlemap grid is generated
            // Could add mouse wheel support, drag to pan, etc.
        }

        function panCenter() {
            battlemapData.displayZoom.centerX = 0.5;
            battlemapData.displayZoom.centerY = 0.5;
            
            if (battlemapData.displayActive) {
                showBattlemapOnDisplay();
            }
        }

        // Character Focus Functions
        function openCharacterFocusModal() {
            populateCharacterFocusList();
            const modal = document.getElementById('characterFocusModal');
            modal.classList.add('active');
        }

        function closeCharacterFocusModal() {
            const modal = document.getElementById('characterFocusModal');
            modal.classList.remove('active');
        }

        function populateCharacterFocusList() {
            const list = document.getElementById('characterFocusList');
            const characters = [];

            // Collect all tokens from the battlemap
            Object.entries(battlemapData.tokens).forEach(([key, token]) => {
                const [x, y] = key.split('-').map(Number);
                characters.push({
                    name: token.name,
                    portrait: token.portrait,
                    x: x,
                    y: y,
                    position: `${x}, ${y}`
                });
            });

            if (characters.length === 0) {
                list.innerHTML = '<div class="empty-state">No characters on the battlemap to focus on.</div>';
                return;
            }

            // Sort by name
            characters.sort((a, b) => a.name.localeCompare(b.name));

            list.innerHTML = characters.map(char => {
                const portraitStyle = char.portrait ? 
                    `background-image: url('file://${char.portrait}');` : 
                    '';
                    
                return `
                    <div class="character-item" onclick="focusOnCharacterAndClose('${char.name}')">
                        <div class="character-portrait-small" style="${portraitStyle}">
                            ${!char.portrait ? char.name.charAt(0).toUpperCase() : ''}
                        </div>
                        <div class="character-info">
                            <div class="character-name">${char.name}</div>
                            <div class="character-position">Position: ${char.position}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function focusOnCharacterAndClose(characterName) {
            const success = focusOnCharacter(characterName);
            if (success) {
                closeCharacterFocusModal();
            }
        }

        // Battlemap Context Menu Functions
        let contextMenuData = { x: 0, y: 0, token: null };

        function showBattlemapContextMenu(event, x, y, token) {
            const contextMenu = document.getElementById('battlemapContextMenu');
            contextMenuData = { x, y, token };
            
            // Generate context menu items based on cell state
            let menuItems = [];
            
            // Focus here option (always available)
            menuItems.push({
                icon: '🎯',
                text: 'Focus Here',
                action: 'focusHere'
            });
            
            if (token) {
                // Cell has a token
                menuItems.push({
                    icon: '🏃‍♂️',
                    text: 'Move',
                    action: 'moveToken'
                });
                
                // Add Hide/Show option based on current visibility
                if (token.hidden) {
                    menuItems.push({
                        icon: '👁️',
                        text: 'Show Token',
                        action: 'showToken'
                    });
                } else {
                    menuItems.push({
                        icon: '👁️‍🗨️',
                        text: 'Hide Token',
                        action: 'hideToken'
                    });
                }
                
                menuItems.push({
                    icon: '🗑️',
                    text: 'Remove Token',
                    action: 'removeToken'
                });
            } else {
                // Empty cell
                menuItems.push({
                    icon: '👤',
                    text: 'Add Token',
                    action: 'addToken'
                });
            }
            
            // Generate menu HTML
            contextMenu.innerHTML = menuItems.map(item => `
                <div class="context-menu-item" onclick="handleContextMenuAction('${item.action}')">
                    <span class="context-menu-icon">${item.icon}</span>
                    <span>${item.text}</span>
                </div>
            `).join('');
            
            // Position the context menu
            const menuRect = contextMenu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            let menuX = event.clientX;
            let menuY = event.clientY;
            
            // Adjust position if menu would go off-screen
            if (menuX + 160 > viewportWidth) { // 160px is min-width of menu
                menuX = event.clientX - 160;
            }
            if (menuY + menuItems.length * 40 > viewportHeight) { // Approximate menu height
                menuY = event.clientY - (menuItems.length * 40);
            }
            
            contextMenu.style.left = menuX + 'px';
            contextMenu.style.top = menuY + 'px';
            contextMenu.style.display = 'block';
            
            // Close menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', hideBattlemapContextMenu, { once: true });
            }, 10);
        }

        function hideBattlemapContextMenu() {
            const contextMenu = document.getElementById('battlemapContextMenu');
            contextMenu.style.display = 'none';
        }

        function handleContextMenuAction(action) {
            const { x, y, token } = contextMenuData;
            
            switch (action) {
                case 'focusHere':
                    focusOnTile(x, y);
                    break;
                case 'addToken':
                    openBattlemapTokenModal(x, y);
                    break;
                case 'moveToken':
                    enterTokenMoveMode(x, y, token);
                    break;
                case 'removeToken':
                    removeTokenFromBattlemap(x, y);
                    break;
                case 'hideToken':
                    // Hide the token
                    const tokenToHide = battlemapData.tokens[`${x}-${y}`];
                    if (tokenToHide) {
                        tokenToHide.hidden = true;
                        saveBattlemapData(); // Save the changes
                        generateBattlemapGrid();
                        if (battlemapData.displayActive) {
                            showBattlemapOnDisplay(); // Update display to hide the token
                        }
                    }
                    break;
                case 'showToken':
                    // Show the token
                    const tokenToShow = battlemapData.tokens[`${x}-${y}`];
                    if (tokenToShow) {
                        tokenToShow.hidden = false;
                        saveBattlemapData(); // Save the changes
                        generateBattlemapGrid();
                        if (battlemapData.displayActive) {
                            showBattlemapOnDisplay(); // Update display to show the token
                        }
                    }
                    break;
            }
            
            hideBattlemapContextMenu();
        }

        function focusOnTile(x, y) {
            // Calculate center position (0 to 1) based on tile position
            battlemapData.displayZoom.centerX = (x + 0.5) / battlemapData.gridWidth;
            battlemapData.displayZoom.centerY = (y + 0.5) / battlemapData.gridHeight;
            
            // Don't change zoom level - preserve current zoom
            // battlemapData.displayZoom.scale = Math.min(2.0, Math.max(1.5, battlemapData.displayZoom.scale));
            
            // Check if there's a visible token at this position
            const tokenAtPosition = battlemapData.tokens[`${x}-${y}`];
            if (tokenAtPosition && !tokenAtPosition.hidden) {
                // Set lastMovedToken to highlight the focused token
                battlemapData.displayZoom.lastMovedToken = {
                    x: x,
                    y: y,
                    name: tokenAtPosition.name
                };
            } else {
                // Clear any previous lastMovedToken highlight
                battlemapData.displayZoom.lastMovedToken = null;
            }
            
            if (battlemapData.displayActive) {
                showBattlemapOnDisplay();
            }
            
            console.log(`Focused on tile ${x},${y} - Center: ${battlemapData.displayZoom.centerX.toFixed(2)}, ${battlemapData.displayZoom.centerY.toFixed(2)}, Zoom: ${battlemapData.displayZoom.scale.toFixed(2)}`);
        }

        function exitTokenMoveMode() {
            battlemapData.moveMode.active = false;
            battlemapData.moveMode.originalPosition = null;
            battlemapData.moveMode.selectedToken = null;
            
            console.log('Exiting move mode');
        }

        // ESC key listener for canceling move mode and closing modals
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (battlemapData.moveMode.active) {
                    exitTokenMoveMode();
                    generateBattlemapGrid();
                } else {
                    // Close any open battlemap modals and context menu
                    hideBattlemapContextMenu();
                    closeCharacterFocusModal();
                    closeBattlemapTokenModal();
                    closeBattlemapBackgroundModal();
                }
            }
            
            // Zoom shortcuts when battlemap tab is active
            if (document.getElementById('battlemapTab').classList.contains('active')) {
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoomIn();
                } else if (e.key === '-') {
                    e.preventDefault();
                    zoomOut();
                } else if (e.key === '0') {
                    e.preventDefault();
                    resetZoom();
                }
            }
        });

        // Initialize zoom button event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Make sure zoom buttons work
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const resetZoomBtn = document.getElementById('resetZoomBtn');
            
            if (zoomInBtn) zoomInBtn.addEventListener('click', zoomIn);
            if (zoomOutBtn) zoomOutBtn.addEventListener('click', zoomOut);
            if (resetZoomBtn) resetZoomBtn.addEventListener('click', resetZoom);
        });

        // Battlemap Display Toggle
        function toggleBattlemapDisplay() {
            if (!battlemapData.backgroundImage) {
                alert('Please select a background image first!');
                return;
            }

            battlemapData.displayActive = !battlemapData.displayActive;
            
            const button = document.getElementById('toggleBattlemapDisplay');
            
            if (battlemapData.displayActive) {
                // Show battlemap on display
                showBattlemapOnDisplay();
                button.textContent = '🔲 Hide from Display';
                button.style.background = 'rgba(231, 76, 60, 0.8)';
            } else {
                // Hide battlemap from display
                hideBattlemapFromDisplay();
                button.textContent = '📺 Show on Display';
                button.style.background = '';
            }
        }

        function showBattlemapOnDisplay() {
            // Send battlemap data to display window including zoom
            window.electronAPI.displayBattlemap({
                backgroundImage: battlemapData.backgroundImage,
                gridWidth: battlemapData.gridWidth,
                gridHeight: battlemapData.gridHeight,
                tokens: battlemapData.tokens,
                zoom: battlemapData.displayZoom
            });
            
            console.log('Displaying battlemap on screen with zoom:', battlemapData.displayZoom);
        }

        function hideBattlemapFromDisplay() {
            window.electronAPI.hideBattlemap();
            console.log('Hiding battlemap from display');
        }

        function generateBattlemapHTML() {
            // Generate a clean HTML version of the battlemap for display
            let html = `
                <div class="display-battlemap" style="
                    display: grid;
                    grid-template-columns: repeat(${battlemapData.gridWidth}, 1fr);
                    gap: 2px;
                    width: 100vw;
                    height: 100vh;
                    background-image: url('file://${battlemapData.backgroundImage}');
                    background-size: cover;
                    background-position: top left;
                    background-repeat: no-repeat;
                    background-attachment: local;
                ">
            `;
            
            // Generate cells with tokens
            for (let y = 0; y < battlemapData.gridHeight; y++) {
                for (let x = 0; x < battlemapData.gridWidth; x++) {
                    const tokenKey = `${x}-${y}`;
                    const token = battlemapData.tokens[tokenKey];
                    
                    html += `<div class="display-battlemap-cell" style="
                        aspect-ratio: 1;
                        position: relative;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">`;
                    
                    if (token) {
                        const tokenStyle = token.portrait ? 
                            `background-image: url('file://${token.portrait}'); background-size: cover; background-position: center;` :
                            `background: linear-gradient(45deg, #3498db, #2980b9); color: white; display: flex; align-items: center; justify-content: center;`;
                        
                        html += `
                            <div class="display-token" style="
                                width: 80%;
                                height: 80%;
                                border-radius: 50%;
                                border: 3px solid #fff;
                                ${tokenStyle}
                                font-size: 1.2vw;
                                font-weight: bold;
                                position: relative;
                            ">
                                ${!token.portrait ? token.name.charAt(0).toUpperCase() : ''}
                                <div class="display-token-name" style="
                                    position: absolute;
                                    bottom: -25px;
                                    left: 50%;
                                    transform: translateX(-50%);
                                    background: rgba(0, 0, 0, 0.8);
                                    color: white;
                                    padding: 2px 8px;
                                    border-radius: 10px;
                                    font-size: 0.8vw;
                                    white-space: nowrap;
                                ">${token.name}</div>
                            </div>
                        `;
                    }
                    
                    html += '</div>';
                }
            }
            
            html += '</div>';
            return html;
        }

        // Battlemap Token Modal Functions
        let battlemapModalPosition = { x: 0, y: 0 };

        function openBattlemapTokenModal(x, y) {
            battlemapModalPosition = { x, y };
            
            // Populate token grid with all available portraits
            populateBattlemapTokenGrid();
            
            const modal = document.getElementById('battlemapTokenModal');
            modal.classList.add('active');
            
            // Focus search input
            setTimeout(() => {
                document.getElementById('battlemapTokenSearchInput').focus();
            }, 100);
        }

        function closeBattlemapTokenModal() {
            const modal = document.getElementById('battlemapTokenModal');
            modal.classList.remove('active');
            document.getElementById('battlemapTokenSearchInput').value = '';
        }

        function populateBattlemapTokenGrid() {
            const grid = document.getElementById('battlemapTokenGrid');
            
            if (!fileStructure) {
                grid.innerHTML = '<div class="empty-state">File structure not loaded. Please switch to Media tab first to load files.</div>';
                return;
            }
            
            // Use the existing collectPortraits function that works in other tabs
            const allPortraits = collectPortraits(fileStructure);
            
            console.log('Found portraits for battlemap:', allPortraits); // Debug log
            
            // Add party members if available
            const partyPortraits = [];
            if (partyData && partyData.length > 0) {
                partyData.forEach(member => {
                    if (member.name) {
                        partyPortraits.push({
                            path: member.portrait,
                            name: member.name,
                            originalName: member.name,
                            isPartyMember: true,
                            searchTerms: member.name.toLowerCase()
                        });
                    }
                });
            }
            
            // Combine party and portrait data
            const allTokens = [...partyPortraits, ...allPortraits];
            
            // Sort alphabetically
            allTokens.sort((a, b) => a.name.localeCompare(b.name));
            
            if (allTokens.length === 0) {
                grid.innerHTML = '<div class="empty-state">No portrait images found. Make sure you have images in your directory!</div>';
                return;
            }
            
            grid.innerHTML = allTokens.map(portrait => {
                const hasImage = portrait.path && portrait.path !== '';
                if (hasImage) {
                    return `
                        <div class="portrait-option" 
                             style="background-image: url('file://${portrait.path}');"
                             onclick="selectBattlemapToken('${portrait.path}', '${portrait.name}', '${portrait.isPartyMember ? 'player' : 'character'}')"
                             data-name="${portrait.searchTerms || portrait.name.toLowerCase()}">
                            <div class="portrait-name">${portrait.name}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="portrait-option no-image" 
                             onclick="selectBattlemapToken('', '${portrait.name}', '${portrait.isPartyMember ? 'player' : 'character'}')"
                             data-name="${portrait.searchTerms || portrait.name.toLowerCase()}">
                            <div class="portrait-placeholder">👤</div>
                            <div class="portrait-name">${portrait.name}</div>
                        </div>
                    `;
                }
            }).join('');
        }

        function selectBattlemapToken(portraitPath, name, type) {
            const { x, y } = battlemapModalPosition;
            const tokenKey = `${x}-${y}`;
            
                    battlemapData.tokens[tokenKey] = {
                        name: name,
                        portrait: portraitPath,
                        type: type,
                        hidden: true // Tokens are hidden by default
                    };            generateBattlemapGrid();
            saveBattlemapData();
            closeBattlemapTokenModal();
            
            // Update display if battlemap is currently showing
            if (battlemapData.displayActive) {
                showBattlemapOnDisplay();
            }
        }

        function removeTokenFromBattlemap(x, y) {
            const tokenKey = `${x}-${y}`;
            if (battlemapData.tokens[tokenKey]) {
                delete battlemapData.tokens[tokenKey];
                generateBattlemapGrid();
                saveBattlemapData();
                
                // Update display if battlemap is currently showing
                if (battlemapData.displayActive) {
                    showBattlemapOnDisplay();
                }
            }
        }

        function filterBattlemapTokens(searchTerm) {
            const tokens = document.querySelectorAll('#battlemapTokenGrid .portrait-option');
            const term = searchTerm.toLowerCase().trim();
            
            tokens.forEach(token => {
                const searchableText = token.getAttribute('data-name') || '';
                const matches = term === '' || searchableText.includes(term);
                token.style.display = matches ? 'block' : 'none';
            });
        }

        // Battlemap data persistence
        async function saveBattlemapData() {
            if (!currentDirectory) return;
            
            try {
                await window.electronAPI.saveBattlemapData(currentDirectory, battlemapData);
                console.log('Battlemap data saved');
            } catch (error) {
                console.error('Error saving battlemap data:', error);
            }
        }

        async function loadBattlemapData() {
            if (!currentDirectory) return;
            
            try {
                const data = await window.electronAPI.loadBattlemapData(currentDirectory);
                if (data) {
                    battlemapData = {
                        backgroundImage: data.backgroundImage || null,
                        gridWidth: data.gridWidth || 20,
                        gridHeight: data.gridHeight || 15,
                        imageAspectRatio: data.imageAspectRatio || null,
                        tokens: data.tokens || {},
                        moveMode: {
                            active: false,
                            selectedToken: null,
                            originalPosition: null
                        },
                        displayActive: false,
                        displayZoom: data.displayZoom || {
                            scale: 1.0,
                            centerX: 0.5,
                            centerY: 0.5,
                            lastMovedToken: null
                        }
                    };
                    
                    // Update UI elements
                    document.getElementById('gridWidth').value = battlemapData.gridWidth;
                    document.getElementById('gridHeight').value = battlemapData.gridHeight;
                    
                    // If we have an image, recalculate its aspect ratio
                    if (battlemapData.backgroundImage) {
                        calculateImageDimensions(battlemapData.backgroundImage);
                    }
                    
                    generateBattlemapGrid();
                    console.log('Battlemap data loaded');
                }
            } catch (error) {
                console.error('Error loading battlemap data:', error);
            }
        }

        // Event listeners for battlemap
        document.getElementById('selectLocationBtn').addEventListener('click', selectBattlemapBackground);
        document.getElementById('clearBattlemapBtn').addEventListener('click', clearBattlemap);
        document.getElementById('saveBattlemapBtn').addEventListener('click', saveBattlemapData);
        document.getElementById('toggleBattlemapDisplay').addEventListener('click', toggleBattlemapDisplay);
        document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
        document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
        document.getElementById('resetZoomBtn').addEventListener('click', resetZoom);

        // Modal close functionality - click outside to close
        window.addEventListener('click', function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });

        // Close modal when clicking outside
        document.getElementById('portraitModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closePortraitModal();
            }
        });
        
        document.getElementById('enemyPortraitModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeEnemyPortraitModal();
            }
        });
        
        document.getElementById('encounterSelectionModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeEncounterSelectionModal();
            }
        });
        
        // Add keyboard support for portrait search
        document.addEventListener('keydown', function(e) {
            const portraitModal = document.getElementById('portraitModal');
            const enemyPortraitModal = document.getElementById('enemyPortraitModal');
            const encounterModal = document.getElementById('encounterSelectionModal');
            const searchInput = document.getElementById('portraitSearchInput');
            const enemySearchInput = document.getElementById('enemyPortraitSearchInput');
            
            if (portraitModal.classList.contains('active')) {
                if (e.key === 'Escape') {
                    closePortraitModal();
                } else if (e.key === 'Enter') {
                    // Select first visible portrait option
                    const firstVisible = portraitModal.querySelector('.portrait-option:not(.hidden)');
                    if (firstVisible) {
                        firstVisible.click();
                    }
                } else if (e.key === '/' && e.target !== searchInput) {
                    // Focus search input when pressing '/'
                    e.preventDefault();
                    searchInput.focus();
                }
            } else if (enemyPortraitModal.classList.contains('active')) {
                if (e.key === 'Escape') {
                    closeEnemyPortraitModal();
                } else if (e.key === 'Enter') {
                    // Select first visible portrait option
                    const firstVisible = enemyPortraitModal.querySelector('.portrait-option:not(.hidden)');
                    if (firstVisible) {
                        firstVisible.click();
                    }
                } else if (e.key === '/' && e.target !== enemySearchInput) {
                    // Focus search input when pressing '/'
                    e.preventDefault();
                    enemySearchInput.focus();
                }
            } else if (encounterModal.classList.contains('active')) {
                if (e.key === 'Escape') {
                    closeEncounterSelectionModal();
                } else if (e.key === 'Enter') {
                    // Select first encounter
                    const firstEncounter = encounterModal.querySelector('.encounter-item');
                    if (firstEncounter) {
                        firstEncounter.click();
                    }
                }
            }
        });

        document.getElementById('refreshBtn').addEventListener('click', () => {
            loadFileStructure();
        });
        
        document.getElementById('refreshBtn2').addEventListener('click', () => {
            loadFileStructure();
        });

        // Initialize dashboard on load
        initializeDashboard();
    </script>
    <!-- Note Modal -->
    <div id="noteModal" class="modal">
        <div class="modal-content note-modal">
            <div class="modal-header">
                <h3>Add Initiative Note</h3>
                <span class="close" onclick="closeNoteModal()">&times;</span>
            </div>
            <form id="noteForm" onsubmit="addInitiativeNote(event)">
                <div class="form-group">
                    <label for="noteInitiative">Initiative Value:</label>
                    <input type="number" id="noteInitiative" min="0" max="50" required>
                </div>
                <div class="form-group">
                    <label for="noteTitle">Note Title:</label>
                    <input type="text" id="noteTitle" placeholder="e.g., Trap activates, Reinforcements arrive" required>
                </div>
                <div class="form-group">
                    <label for="noteDescription">Description (optional):</label>
                    <textarea id="noteDescription" placeholder="Additional details about this initiative event..." rows="3"></textarea>
                </div>
                <div class="modal-actions">
                    <button type="submit" class="primary-btn">Add Note</button>
                    <button type="button" class="secondary-btn" onclick="closeNoteModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

</body>
</html>
